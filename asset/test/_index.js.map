{"version":3,"sources":["../src/core/utils.ts","utils.js","../src/core/env.ts","env.js","../src/core/rules.ts","../src/core/schema.ts","schema.js","_index.js"],"names":["run","assert","assertError","assertUndefined","U","appendPath","commonPath","validate","value","schema","json","name","age","buddies","env","E","makeEnv","extract","test","add","remove","join","slot80","getSlot","invalid","setSlot","replace","env2","foo","move","copy","mapDeep","slot","path","message","reduceDeep","cur","endUpdateTracking","beginUpdateTracking","v","S","defaultRules","c","coerce","s","type","undefined","enum","required","bar","baz","switchRequired","tagProperty","types","infix","app","var","lit","lambda","data","op","lhs","rhs","f","arg","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","maxItems","minItems","same","first","second","properties","at","to","if","ident","thunk","rv","lv","console","log","match","status","e","Error","startsWith","callRun","m"],"mappings":"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","file":"_index.js","sourceRoot":"..\\..\\tests","sourcesContent":["\r\n/**\r\n * Some utility functions.\r\n * \r\n * @module core/utils \r\n */\r\n\r\nimport showText from 'string-template'\r\n\r\n/**\r\n * JSON path's index portion.  \r\n * We handle JSON path of `\"/abc/1/def\"` as an index array of `[\"abc\", 1, \"def\"]`.\r\n * \r\n * @category Types\r\n */\r\nexport type Index = string|number\r\n\r\n/**\r\n * Returns true if x is an string representation of an integer value.\r\n * \r\n * @example\r\n * ```js\r\n * isIntStr(\"abc\");  // => false\r\n * isIntStr(\"123\");  // => true\r\n * isIntStr(\"1a\");   // => false\r\n * ```\r\n * @category Entries\r\n */\r\nexport const isIntStr = (x:string):boolean => {\r\n  const n = +x\r\n  return (n % 1 === 0 && x === \"\" + n)\r\n}\r\n\r\n/**\r\n * Returns the array-index independent normalized path.\r\n * \r\n * @example\r\n * ```\r\n * normalizePath(\"/abc/1/def\");  // => \"/abc/\" + \"*\" + \"/def\"\r\n * ```\r\n * @category Entries\r\n */\r\nexport const normalizePath = (path:string):string => {\r\n  const frags = path.split('/')\r\n  for (let i = 1; i < frags.length; i++) {\r\n    if (isIntStr(frags[i])) {\r\n      frags[i] = '*'\r\n    }\r\n  }\r\n  return frags.join('/')\r\n}\r\n\r\n/**\r\n * Concatenates two paths, `path' can be a relative one.\r\n * It roughly follows the Relative JSON path standard.\r\n * \r\n * @example\r\n * ```\r\n * appendPath(\"/abc/def\", \"1/zzz\");  // => \"/abc/zzz\"\r\n * appendPath(\"/abc/def\", \"0/zzz\");  // => \"/abc/def/zzz\"\r\n * appendPath(\"/abc/def\", \"/zzz\");   // => \"/zzz\"\r\n * ```\r\n * @category Entries\r\n */\r\nexport const appendPath = (base:string, path:string):string => {\r\n  if (path.charAt(0) == '' || path.charAt(0) == '/') return path  // absolute path\r\n  if (path === '0') return base  // easy frequent case\r\n  \r\n  const base1 = pathToArray(base)\r\n  let frag0 = path.split('/')\r\n  let frag = []\r\n  let unused = null\r\n\r\n  let upcount = +frag0[0]\r\n  frag = base1\r\n  if (upcount > frag.length) {\r\n    upcount = frag.length\r\n  }\r\n  frag.splice(frag.length - upcount, upcount)\r\n\r\n  frag0.shift()\r\n\r\n  if (frag0.length == 0 && frag.length == 0) return ''\r\n  return '/' + frag.concat(frag0).join('/')\r\n}\r\n\r\n/**\r\n * Normalizes not a string path but an array path, then returns a normalized string path.\r\n * \r\n * @category Entries\r\n */\r\nexport const normalizePathArray = (path:Index[]):string => {\r\n  let rv = ''\r\n  for (let i = 0; i < path.length; i++) {\r\n    if (typeof path[i] == 'number' || isIntStr(\"\" + path[i])) {\r\n      rv += '/*'\r\n    } else {\r\n      rv += '/' + path[i]\r\n    }\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * Separates a path described by a string into an Index array.\r\n * \r\n * @category Entries\r\n */\r\nexport const pathToArray = (path:string):Index[] => {\r\n  const frags = path.split('/')\r\n  const rv = []\r\n  for (let i = 1; i < frags.length; i++) {\r\n    rv.push(isIntStr(frags[i]) ? +frags[i] : frags[i])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * A variant of `typeof', which handles null and Array appropreately.\r\n * \r\n * @example\r\n * ```\r\n * typeOf([]);    // => 'array'\r\n * typeOf(null);  // => 'null'\r\n * ```\r\n * @category Entries\r\n */\r\nexport const typeOf = (x:any):string => x === null ? 'null' : Array.isArray(x) ? 'array' : typeof x\r\n\r\n/**\r\n * Returns true if `x' is a json value. This is just a shallow test.\r\n * \r\n * @category Entries\r\n */\r\nexport const isJsonValue = (x:any):boolean => {\r\n  switch (typeOf(x)) {\r\n    case 'null': \r\n    case 'number': \r\n    case 'boolean': \r\n    case 'string': \r\n    case 'object': \r\n    case 'array': \r\n      return true\r\n    default: \r\n      return false\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts common portion of paths.\r\n * \r\n * @example\r\n * ```\r\n * commonPath(\"/abc/def\", \"/abc/zzz\");  // => \"/abc\"\r\n * commonPath(\"/abc/def\", \"/abc/deX\");  // => \"/abc\"\r\n * commonPath(\"/abc\", \"/xxx\");  // => \"\"\r\n * commonPath(\"/abc/def/aaa\", \"/abc/def/bbb\");  // => \"/abc/def\"\r\n * ```\r\n * @category Entries\r\n */\r\nexport const commonPath = (path1:string, path2:string):string => {\r\n  const frags1 = path1.split('/')\r\n  const frags2 = path2.split('/')\r\n  const rv = []\r\n  for (let i = 0; i < frags1.length; i++) {\r\n    if (frags2.length <= i) break\r\n    if (frags1[i] != frags2[i]) break\r\n    rv.push(frags1[i])\r\n  }\r\n  return rv.join('/')\r\n}\r\n\r\n/**\r\n * Builds a query string from `obj'.\r\n * \r\n * @category Entries\r\n */\r\nexport const normalizeQuery = (obj:Record<string,string>, omitEmptyParam:boolean):Record<string,string> => {\r\n  const rv = /** @type {Record<string, string>} */ ({})\r\n  for (let p in obj) {\r\n    switch (typeOf(p)) {\r\n      case 'null': \r\n        if (!omitEmptyParam) rv[p] = ''\r\n        break\r\n      case 'boolean': \r\n        rv[p] = obj[p] ? 'true' : 'false'\r\n        break\r\n      case 'number': \r\n        rv[p] = \"\" + obj[p]\r\n        break\r\n      case 'string': \r\n        if (omitEmptyParam && obj[p] === \"\") break\r\n        rv[p] = obj[p]\r\n        break\r\n    }\r\n  }\r\n  return rv\r\n}\r\n\r\nexport {showText}","\r\nimport * as U from '../src/core/utils'\r\n\r\nexport const run = (assert, assertError, assertUndefined) => {\r\n  assert(1, () => U.appendPath('/a/b', '0/c/d'), '/a/b/c/d')\r\n  assert(1.1, () => U.appendPath('', '0/c'), '/c')\r\n  assert(1.2, () => U.appendPath('/a/b', '/x/y'), '/x/y')\r\n  assert(1.3, () => U.appendPath('/a/b/c', '1/d/e'), '/a/b/d/e')\r\n  assert(1.4, () => U.appendPath('/a', '3/z'), '/z')\r\n  assert(1.5, () => U.appendPath('/a/b', '1'), '/a')\r\n  assert(1.6, () => U.appendPath('/a/b/c', '3'), '')\r\n\r\n  assert(2, () => U.commonPath('/a/b/c', '/a/b/c'), '/a/b/c')\r\n  assert(2.1, () => U.commonPath('/a/b/c', '/a/b/d'), '/a/b')\r\n  assert(2.2, () => U.commonPath('/a/b/c', '/a'), '/a')\r\n  assert(2.3, () => U.commonPath('/a/b/c', ''), '')\r\n}","/**\r\n * This is the core data store object in Unmagical, and it is an abstract data type.\r\n * @module core/env\r\n */\r\n\r\nimport {normalizePath, typeOf, isIntStr, normalizePathArray, appendPath, Index} from './utils'\r\nimport rhasPath from 'ramda/src/hasPath'\r\nimport init from 'ramda/src/init'\r\nimport rpath from 'ramda/src/path'\r\nimport assocPath from 'ramda/src/assocPath'\r\nimport insert from 'ramda/src/insert'\r\nimport last from 'ramda/src/last'\r\nimport dissoc from 'ramda/src/dissoc'\r\nimport rremove from 'ramda/src/remove'\r\nimport update from 'ramda/src/update'\r\nimport {Json, Schema, Slot, SchemaDb, Lookup, Validate} from './schema'\r\n\r\n\r\n/**\r\n * Env is the abstract data type.\r\n * @ignore\r\n */\r\nexport type Env = {\r\n  tree: Json, \r\n  trackUpdate: boolean, \r\n  updatePoint: Index[], \r\n  schemaDb: SchemaDb, \r\n  validate: Validate, \r\n  extra: Record<string,any>, \r\n  ret?: any, \r\n  onPromiseThen?: any\r\n}\r\n\r\n\r\n/**\r\n * see: https://github.com/ramda/ramda/pull/2841\r\n * Anyway, here we fix the original behavior.\r\n * @function\r\n * @private\r\n * @param {string[]} path \r\n * @param {any} x \r\n * @return {boolean}\r\n */\r\nconst hasPath = (path:Index[], x:any):boolean => {\r\n  if (! path.length) return true\r\n  return rhasPath(path as string[], x)\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n */\r\nconst init2 = <T>(list:T[]) => {\r\n  return init(init(list))\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} value \r\n * @return {Slot} \r\n */\r\nconst makeSlot = (value:Json):Slot => {\r\n  const rv:Slot = {value, invalid:false, error:null}\r\n  switch (typeOf(value)) {\r\n    case 'object': // FALLTHRU\r\n    case 'array': \r\n      break\r\n    case 'number': // FALLTHRU\r\n    case 'integer': \r\n      rv.input = '' + value\r\n      rv.touched = false\r\n      break\r\n    case 'boolean': \r\n      rv.input = (value) ? 'true' : 'false'\r\n      rv.touched = false\r\n      break\r\n    case 'null': \r\n      rv.input = ''\r\n      rv.touched = false\r\n      break\r\n    case 'string': \r\n      rv.input = value as string\r\n      rv.touched = false\r\n      break\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} data \r\n * @returns {Slot}\r\n */\r\nconst wrap = (data):Slot => {\r\n  /** @type {(data:Json) => Slot} */\r\n  const inner = (data:Json):Slot => {\r\n    switch (typeOf(data)) {\r\n      case 'array': \r\n        const es = []\r\n        for (let i = 0; i < (data as Json[]).length; i++) {\r\n          es[i] = inner(data[i])\r\n        }\r\n        return makeSlot(es)\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in (data as Object)) {\r\n          rec[p] = inner(data[p])\r\n        }\r\n        return makeSlot(rec)\r\n      default: \r\n        return makeSlot(data)\r\n    }\r\n  }\r\n  return inner(data)\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} tree \r\n * @returns {Json}\r\n */\r\nconst strip = (tree:Json):Json => {\r\n  const root = (tree as Slot).value\r\n  switch (typeOf(root)) {\r\n    case 'array': \r\n      const es = []\r\n      for (let i = 0; i < (root as Json[]).length; i++) {\r\n        es[i] = strip(root[i])\r\n      }\r\n      return es\r\n    case 'object': \r\n      const rec = {}\r\n      for (let p in (root as Object)) {\r\n        rec[p] = strip(root[p])\r\n      }\r\n      return rec\r\n    default: \r\n      return root\r\n  }\r\n}\r\n\r\n/**\r\n * @en Makes env.\r\n * @ja Envを作る。\r\n * @param data\r\n * - `en` initial data\r\n * - `ja` 初期データ\r\n * @param schemaDb\r\n * - `en` schema database\r\n * - `ja` スキーマデータベース\r\n * @param validate\r\n * - `en` validation function\r\n * - `ja` バリデーション関数\r\n * @param trackUpdate\r\n * - `en` if true, then env is created with update tracking in place.\r\n * - `ja` trueならenvはアップデートトラッキングをしている状態で作られます。\r\n * @returns \r\n * - `en` newly created env\r\n * - `ja` 新しく作成されたenv\r\n * \r\n * @category Entries\r\n */\r\nexport const makeEnv = (data:Json, schemaDb:SchemaDb, validate:Validate, trackUpdate:boolean):Env => {\r\n  const tree = wrap(data) as Json\r\n  return {\r\n    tree, \r\n    trackUpdate, \r\n    updatePoint: trackUpdate ? [] : null, \r\n    schemaDb, \r\n    validate, \r\n    extra: {}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env0 \r\n * @param {Env} env1 \r\n * @returns {boolean}\r\n * \r\n * @category Entries\r\n */\r\nexport const isSame = (env0:Env, env1:Env):boolean => {\r\n  return (env0.tree === env1.tree && env0.extra === env1.extra)\r\n}\r\n\r\n/**\r\n * Internalizes a path\r\n * @function\r\n * @private\r\n * @param {string} path \r\n * @returns {(string|number)[]}\r\n */\r\nconst internPath = (path:string):Index[] => {\r\n  const frags = path.split('/')\r\n  const rv = []\r\n  for (let i = 1; i < frags.length; i++) {\r\n    rv.push('value')\r\n    rv.push(isIntStr(frags[i]) ? +frags[i] : frags[i])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {(string|number)[]} path \r\n * @returns {string}\r\n */\r\nconst externPath = (path:Index[]):string => {\r\n  let rv = \"\"\r\n  for (let i = 0; i < path.length; i += 2) {\r\n    rv += \"/\" + path[i + 1]\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {((string|number)[])|null} path0 \r\n * @param {((string|number)[])|null} path1\r\n * @returns {((string|number)[])|null} \r\n */\r\nconst intersect = (path0:Index[]|null, path1:Index[]|null):Index[]|null => {\r\n  if (path0 === null) return path1\r\n  if (path1 === null) return path0\r\n\r\n  const rv = []\r\n  for (let i = 0; i < path0.length; i += 2) {\r\n    if (i >= path1.length) break\r\n    if (path0[i + 1] !== path1[i + 1]) break\r\n    rv.push(path0[i])\r\n    rv.push(path0[i + 1])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env \r\n * @returns {Env}\r\n * \r\n * @category Entries\r\n */\r\nexport const beginUpdateTracking = (env:Env):Env => {\r\n  // Essentially, `updatePoint' should be set to null, but it can be omitted \r\n  // because the value when disabled is null.\r\n  return {...env, trackUpdate:true}\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env \r\n * @returns {[string|null, Env]}\r\n * \r\n * @category Entries\r\n */\r\nexport const endUpdateTracking = (env:Env):[string|null, Env] => {\r\n  const updatePoint = env.updatePoint ? externPath(env.updatePoint) : null\r\n  console.log('update occurred at ' + JSON.stringify(updatePoint))\r\n  return [\r\n    updatePoint, \r\n    {...env, trackUpdate:false, updatePoint:null}\r\n  ]\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {boolean}\r\n * \r\n * @category Entries\r\n */\r\nexport const test = (path:string, env:Env):boolean => {\r\n  return hasPath(/** @type {string[]} */ (internPath(path)), env.tree)\r\n}\r\n\r\n/**\r\n * Extracts a subtree of Env.\r\n * @function\r\n * @param {string} path\r\n * @param {Env} env\r\n * @returns {Json}\r\n * \r\n * @category Entries\r\n */\r\nexport const extract = (path:string, env:Env):Json => {\r\n  const epath = /** @type {string[]} */ (internPath(path))\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('extract/1: not found: ' + path)\r\n  }\r\n  return strip(slot as Json)\r\n}\r\n\r\n/**\r\n * Low-level api.\r\n * @function\r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Slot} \r\n * \r\n * @category Entries\r\n */\r\nexport const getSlot = (path:string, env:Env):Slot => {\r\n  const epath = /** @type {string[]} */ (internPath(path))\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('getSlot/1: not found: ' + path)\r\n  }\r\n  return slot\r\n}\r\n\r\n/**\r\n * Low-level api. This function executes neither validation nor coercion.\r\n * @function\r\n * @param {string} path \r\n * @param {Slot} slot \r\n * @param {Env} env\r\n * @returns {Env} \r\n * \r\n * slot value must be a scalar.\r\n * \r\n * @category Entries\r\n */\r\nexport const setSlot = (path:string, slot:Slot, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree) as Slot\r\n  if (! slot0) {\r\n    throw new Error('setSlot/1: not found: ' + path)\r\n  }\r\n  switch (typeOf(slot0.value)) {\r\n    case 'null': \r\n    case 'boolean': \r\n    case 'number': \r\n    case 'string': \r\n    case 'undefined': \r\n      break\r\n    default: \r\n      throw new Error('setSlot/2: not a scalar: ' + path)\r\n  }\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n  return {...env, tree, updatePoint}\r\n}\r\n\r\n/**\r\n * Adds value to env. `add' function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Json} value \r\n * @param {Env} env \r\n * @returns {Env}\r\n * \r\n * @category Entries\r\n */\r\nexport const add = (path:string, value:Json, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('add/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // insert into array\r\n    const index = (name === '-') ? (slot0.value as Json[]).length : name\r\n    if (typeof index != 'number' || index % 1 !== 0) {\r\n      throw new Error('add/2 invalid index: ' + path)\r\n    }\r\n    if (index < 0 || index > (slot0.value as Json[]).length) {\r\n      throw new Error('add/3 index out of range: ' + path)\r\n    }\r\n    const value1 = wrap(value) as Json\r\n    const lis = insert(index, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    // Insertion to a list is an update not to an item but to the list.\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // define or replace into object\r\n    if (typeof name != 'string') {\r\n      throw new Error('add/4 invalid name: ' + path)\r\n    }\r\n    const value1 = wrap(value)\r\n    const rec = {...(slot0.value as {[prop:string]:Json}), [name]:value1} as Json\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    // Adding a property is an update to an object, while replacing a property is an update to an property value.\r\n    const updatePoint = !env.trackUpdate ? env.updatePoint \r\n      : intersect(env.updatePoint, (name in (slot0.value as Object)) ? epath : location)\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Removes a value specified by path from env. `remove' function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {Env}\r\n * @category Entries\r\n */\r\nexport const remove = (path:string, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('remove/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // removes from array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('remove/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('remove/3 out of range: ' + path)\r\n    }\r\n    const lis = rremove(name, 1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // delete property from object\r\n    if (! slot0.value.hasOwnProperty(name)) {\r\n      throw new Error('remove/4: property not found: ' + path)\r\n    }\r\n    const rec = dissoc(name as never, slot0.value as object)\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Replaces a value specified by path into value.  Implements replace function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Json} value \r\n * @param {Env} env \r\n * @returns {Env}\r\n * @category Entries\r\n */\r\nexport const replace = (path:string, value:Json, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  if (epath.length == 0) {\r\n    // replace whole data\r\n    const tree = wrap(value) as Json\r\n    const updatePoint = env.trackUpdate ? [] : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('replace/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // replace an element in array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('replace/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('replace/3 out of range: ' + path)\r\n    }\r\n    const value1 = wrap(value) as Json\r\n    const lis = update(name, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // replace a property of object\r\n    if (typeof name != 'string') {\r\n      throw new Error('replace/4 invalid name: ' + path)\r\n    }\r\n    if (!(name in (slot0.value as {[prop:string]:Json}))) {\r\n      throw new Error('replace/5 undefined property: ' + path)\r\n    }\r\n    const value1 = wrap(value)\r\n    const rec = {...(slot0.value as {[prop:string]:Json}), [name]:value1} as {[prop:string]:Json}\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Moves a value located in from, to a location specified by path.  Implements move function of JSON patch.\r\n * @function\r\n * @param {string} from \r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n * @category Entries\r\n */\r\nexport const move = (from:string, path:string, env:Env):Env => {\r\n  const value = extract(from, env)\r\n  env = remove(from, env)\r\n  env = add(path, value, env)\r\n  return env\r\n}\r\n\r\n/**\r\n * Copies a value located in from, to a location specified by path.  Impelementing copy function of JSON patch.\r\n * @function\r\n * @param {string} from \r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n * @category Entries\r\n */\r\nexport const copy = (from:string, path:string, env:Env):Env => {\r\n  const value = extract(from, env)\r\n  env = add(path, value, env)\r\n  return env\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n * @category Entries\r\n */\r\nexport const validate = (path:string, env:Env):Env => {\r\n  let basePath = null\r\n\r\n  /**\r\n   * \r\n   * @param {string} path \r\n   * @returns {Json}\r\n   */\r\n  const lookup = (path) => {\r\n    const pathToLookup = appendPath(basePath, path)\r\n    return extract(pathToLookup, env)\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {Slot} slot0 \r\n   * @param {string} npath\r\n   * @param {string} path\r\n   * @returns {Slot} \r\n   */\r\n  const inner = (slot0:Slot, npath:string, path:string):Slot => {\r\n    const value0 = slot0.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        const lis = []\r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          lis[i] = inner(value0[i], npath + '/*', path + '/' + i)\r\n        }\r\n        basePath = path\r\n        return env.validate(lis, slot0, env.schemaDb[npath], lookup)\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in  (value0 as Record<string,Json>)) {\r\n          rec[p] = inner(value0[p], npath + '/' + p, path + '/' + p)\r\n        }\r\n        basePath = path\r\n        return env.validate(rec, slot0, env.schemaDb[npath], lookup)\r\n      default: \r\n        basePath = path\r\n        const slot = env.validate(value0, slot0, env.schemaDb[npath], lookup)\r\n        if (slot.value !== value0) {\r\n          throw new Error('validate/0: value changed: ' + path)\r\n        }\r\n        return slot\r\n    }\r\n  }\r\n\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree)\r\n  if (! slot0) {\r\n    throw new Error('validate/1: not found: ' + path)\r\n  }\r\n  const slot = inner(slot0, normalizePath(path), path)\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  return {...env, tree}\r\n}\r\n\r\n/**\r\n * By f, maps every slot descending to a location specified by path.\r\n * @category Entries\r\n */\r\nexport const mapDeep = (f:(slot:Slot, path:string) => Slot, path:string, env:Env):Env => {\r\n  const inner = (slot0:Slot, path:string):Slot => {\r\n    const value0 = slot0.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        const lis = []\r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          lis[i] = inner(value0[i], path + '/' + i)\r\n        }\r\n        return {...f(slot0, path), value:lis}\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in (value0 as Record<string,Json>)) {\r\n          rec[p] = inner(value0[p], path + '/' + p)\r\n        }\r\n        return {...f(slot0, path), value:rec}\r\n      default: \r\n        return {...f(slot0, path), value:value0}\r\n    }\r\n  }\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree)\r\n  if (! slot0) {\r\n    throw new Error('mapDeep/1: not found: ' + path)\r\n  }\r\n  const slot = inner(slot0, path)\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  return {...env, tree}\r\n}\r\n\r\n/**\r\n * By f, deeply reduces a subtree of path.\r\n * @function\r\n * @template T\r\n * @param {ReduceSlotFunc<T>} f \r\n * @param {T} cur \r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {T}\r\n * @category Entries\r\n */\r\nexport const reduceDeep = <T>(f:(cur:T, slot:Slot, path:string) => T, cur:T, path:string, env:Env):T => {\r\n  const inner = (cur:T, slot:Slot, path:string):T => {\r\n    const value0 = slot.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          cur = inner(cur, value0[i], path + '/' + i)\r\n        }\r\n        return f(cur, slot, path)\r\n      case 'object': \r\n        for (let p in (value0 as Record<string,Json>)) {\r\n          cur = inner(cur, value0[p], path + '/' + p)\r\n        }\r\n        return f(cur, slot, path)\r\n      default: \r\n        return f(cur, slot, path)\r\n    }\r\n  }\r\n  const epath = internPath(path)\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('reduceDeep/1: not found: ' + path)\r\n  }\r\n  return inner(cur, slot, path)\r\n}\r\n\r\n/**\r\n * \r\n * @param path \r\n * @param fromEnv \r\n * @param toEnv \r\n * @category Entries\r\n */\r\nexport const duplicate = (path:string, fromEnv:Env, toEnv:Env):Env => {\r\n  const epath = internPath(path)\r\n  if (epath.length == 0) {\r\n    // duplicate whole data\r\n    const tree = fromEnv.tree\r\n    const updatePoint = toEnv.trackUpdate ? [] : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  }\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, fromEnv.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('duplicate/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // duplicate an element in an array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('duplicate/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('duplicate/3 out of range: ' + path)\r\n    }\r\n    const value1 = slot0.value[name]\r\n    const lis = update(name, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, toEnv.tree)\r\n    const updatePoint = toEnv.trackUpdate ? intersect(toEnv.updatePoint, epath) : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  } else {\r\n    // duplicate a property of an object\r\n    if (typeof name != 'string') {\r\n      throw new Error('replace/4 invalid name: ' + path)\r\n    }\r\n    if (!(name in (slot0.value as Record<string,Json>))) {\r\n      throw new Error('replace/5 undefined property: ' + path)\r\n    }\r\n    const value1 = slot0.value[name]\r\n    const rec = {...(slot0.value as Record<string,Json>), [name]:value1}\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, toEnv.tree)\r\n    const updatePoint = toEnv.trackUpdate ? intersect(toEnv.updatePoint, epath) : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} name \r\n * @param {Object|null} info \r\n * @param {Env} env\r\n * @returns {Env} \r\n * @category Entries\r\n */\r\nexport const setExtra = (name:string, info:Object|null, env:Env):Env => {\r\n  if (info === null) {\r\n    const {[name]:_unused, ...extra} = env.extra\r\n    return {...env, extra}\r\n  } else {\r\n    const extra = {...env.extra, [name]:info}\r\n    return {...env, extra}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} name \r\n * @param {Env} env\r\n * @returns {Object|null} \r\n * @category Entries\r\n */\r\nexport const getExtra = (name:string, env:Env):Object|null => {\r\n  return env.extra[name] || null\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {any} ret \r\n * @param {any} onPromiseThen\r\n * @param {Env} env \r\n * @returns {Env}\r\n * @category Entries\r\n */\r\nexport const setPortal = (ret:any, onPromiseThen:any, env:Env):Env => {\r\n  if (ret) return {...env, ret, onPromiseThen}\r\n  const {ret:_unused, onPromiseThen:_unused2, ...env2} = env\r\n  return env2\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env\r\n * @returns {void} \r\n * @category Entries\r\n */\r\nexport const doReturn = (env:Env):void => {\r\n  if (env.ret) {\r\n    env.ret(env)\r\n  } else {\r\n    throw new Error('doReturn/0: no ret')\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {any} x\r\n * @returns {boolean} \r\n * @category Entries\r\n */\r\nexport const isEnv = (x:any):boolean => {\r\n  return (x != null \r\n    && typeof x == \"object\" \r\n    && \"tree\" in x)\r\n}","\r\nimport * as E from '../src/core/env'\r\n\r\nconst validate = (value, schema) => {\r\n  //console.log('validate called', value, path)\r\n  return {'@value':value}\r\n}\r\n\r\nexport const run = (assert, assertError) => {\r\n  const json = {\r\n    name: 'Bob', \r\n    age: 24, \r\n    buddies: [\r\n      'Mam', 'Dad'\r\n    ]\r\n  }\r\n\r\n  let env = E.makeEnv(json, {}, validate, true)\r\n  assert(1, () => E.extract('/name', env), 'Bob')\r\n  assert(1.1, () => E.test('/name', env), true)\r\n  assert(1.2, () => E.test('/foo', env), false)\r\n\r\n  env = E.add('/email', 'info@example.com', env)\r\n  assert(2, () => E.extract('/email', env), 'info@example.com')\r\n  assertError(2.1, () => E.extract('/foo', env), 'extract/')\r\n\r\n  assert(3, () => E.extract('/buddies/1', env), 'Dad')\r\n\r\n  env = E.add('/buddies/1', 'Pochi', env)  // Mam,Pochi,Dad\r\n  assert(4, () => E.extract('/buddies/1', env), 'Pochi')\r\n  assertError(4.1, () => E.extract('/buddies/5', env), 'extract/')\r\n\r\n  env = E.add('/buddies/-', 'Komino', env)  // Mam,Pochi,Dad,Komino\r\n  assert(5, () => E.extract('/buddies/3', env), 'Komino')\r\n\r\n  env = E.remove('/buddies/3', env)  // Mam,Pochi,Dad\r\n  assert(6, () => E.extract('/buddies', env).join(','), 'Mam,Pochi,Dad')\r\n  assertError(6.1, () => E.extract('/buddies/3', env), 'extract/')\r\n\r\n  env = E.remove('/email', env)\r\n  assertError(7, () => E.extract('/email', env), 'extract/')\r\n  assertError(7.1, () => E.remove('/email', env), 'remove/')\r\n\r\n  assert(8, () => {\r\n    let slot80 = E.getSlot('/name', env)\r\n    slot80 = {...slot80, invalid:true}\r\n    env = E.setSlot('/name', slot80, env)\r\n    slot80 = E.getSlot('/name', env)\r\n    return slot80.invalid\r\n  }, true)\r\n\r\n  env = E.replace('/age', 30, env)\r\n  assert(9, () => E.extract('/age', env), 30)\r\n  let env2 = E.replace('', {foo:1}, env)\r\n  assert(9.1, () => E.extract('/foo', env2), 1)\r\n  assertError(9.2, () => E.extract('/age', env2), 'extract/')\r\n\r\n  env = E.add('/id', 'TS1101', env)\r\n  env = E.move('/id', '/employeeId', env)\r\n  assert(10, () => E.extract('/employeeId', env), 'TS1101')\r\n  assertError(10.1, () => E.extract('/id', env), 'extract/')\r\n\r\n  env = E.copy('/employeeId', '/id', env)\r\n  assert(11, () => E.extract('/employeeId', env), 'TS1101')\r\n  assert(11.1, () => E.extract('/id', env), 'TS1101')\r\n\r\n  assert(11.9, () => E.extract('/buddies', env).join(','), 'Mam,Pochi,Dad')\r\n  env = E.move('/buddies/2', '/buddies/0', env)  // Dad,Mam,Pochi\r\n  assert(12, () => E.extract('/buddies', env).join(','), 'Dad,Mam,Pochi')\r\n\r\n  env = E.copy('/buddies/0', '/buddies/2', env)  // Dad,Mam,Dad,Pochi\r\n  assert(13, () => E.extract('/buddies', env), 'Dad,Mam,Dad,Pochi')\r\n\r\n  env = E.mapDeep((slot, path) => ({...slot, message:'yeah'}), '/buddies', env)\r\n  assert(14, () => E.getSlot('/buddies', env).message, 'yeah')\r\n  assert(14.1, () => E.getSlot('/buddies/0', env).message, 'yeah')\r\n  assert(14.2, () => E.getSlot('/name', env).message || '', '')\r\n\r\n  assert(15, () => {\r\n    return E.reduceDeep((cur, slot, path) => {\r\n      if (path == '/buddies') return cur\r\n      return cur + `[${slot.value}]`\r\n    }, \"\", '/buddies', env)\r\n  }, '[Dad][Mam][Dad][Pochi]')\r\n\r\n  env = E.makeEnv(json, {}, validate, true)\r\n  assert(16, () => E.endUpdateTracking(env)[0], \"\")\r\n  env = E.endUpdateTracking(env)[1]\r\n  env = E.beginUpdateTracking(env)\r\n  env = E.replace('/age', 30, env)\r\n  assert(16.1, () => E.endUpdateTracking(env)[0], \"/age\")\r\n  env = E.add('/name', 'Jack', env)\r\n  assert(16.2, () => E.endUpdateTracking(env)[0], \"\")\r\n  env = E.makeEnv(json, {}, validate, false)\r\n  env = E.beginUpdateTracking(env)\r\n  env = E.add('/buddies/-', 'Puppy', env)\r\n  assert(16.3, () => E.endUpdateTracking(env)[0], \"/buddies\")\r\n  env = E.remove('/name', env)\r\n  assert(16.4, () => E.endUpdateTracking(env)[0], \"\")\r\n}\r\n\r\n","/**\r\n * Predefined valiation rules\r\n * \r\n * @module core/rules\r\n */\r\n\r\nimport {typeOf} from './utils'\r\nimport {Scalar} from './errors'\r\nimport {RuleFunc, Json, Schema, nullable, applyRules} from './schema'\r\n\r\n\r\ntype SwitchRequiredParam = {tagProperty:string, types:{[tag:string]:string[]}}\r\n\r\ntype IfParam = [string, Schema, Schema, Schema?]\r\n\r\n/**\r\n * Returns true if the value is in an specified type\r\n */\r\nconst testType = (value:Json, type:string):boolean => {\r\n  if (! type) return true\r\n  if (value === null) {\r\n    return nullable(type)\r\n  } else {\r\n    switch (type) {\r\n      case 'null': \r\n        return false\r\n      case 'number':  // FALLTHRU\r\n      case 'number?': \r\n        return typeof value == 'number'\r\n      case 'integer':  // FALLTHRU\r\n      case 'integer?': \r\n        return (typeof value == 'number' && value % 1 === 0)\r\n      case 'boolean':  // FALLTHRU\r\n      case 'boolean?': \r\n        return typeof value == 'boolean'\r\n      case 'string': \r\n        return typeof value == 'string'\r\n      case 'object':  // FALLTHRU\r\n      case 'object?': \r\n        return (typeof value == 'object' && value !== null)\r\n      case 'array':  // FALLTHRU\r\n      case 'array?': \r\n        return Array.isArray(value)\r\n      default: \r\n        throw new Error('unknown type: ' + type)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Valid if a type of `value` is that specified by `param`.\r\n * @param param null|boolean|boolean?|integer|integer?|number|number?|string|object|object?|array|array?\r\n * @param value value to validate\r\n * @category Predefined Rules\r\n */\r\nexport const type:RuleFunc = (param, value) => {\r\n  if (typeof param != 'string') throw new Error('invalid type')\r\n  const result = testType(value, param)\r\n  if (! result) return {code:'type.'+param}\r\n  return true\r\n}\r\n\r\n/**\r\n * Valid if `value` is either of values in `param`. Comparison is executed with `===`.\r\n * @param param candidates\r\n * @param value value to validate\r\n * @category Predefined Rules\r\n */\r\nexport const $enum:RuleFunc = (param:Json[], value) => {\r\n  if (! Array.isArray(param)) throw new Error('invalid parameter')\r\n  for (let i = 0; i < param.length; i++) {\r\n    if (param[i] === value) return true\r\n  }\r\n  return {code:'rule.enum'}\r\n}\r\n\r\n/**\r\n * Valid if `value` is `===` to `param`.\r\n * @param param const\r\n * @param value value to validate\r\n * @category Predefined Rules\r\n */\r\nexport const $const:RuleFunc = (param, value) => {\r\n  if (param === value) return true\r\n  switch (typeOf(param)) {\r\n    case 'string': \r\n    case 'number': \r\n    case 'null': \r\n    case 'boolean': \r\n      return {code:'rule.const', hint:(param as Scalar)}\r\n    default: \r\n      return {code:'rule.const.nohint'}\r\n  }\r\n}\r\n\r\n/**\r\n * Valid if `value` is not a empty string.<br>\r\n * If `value` is not a string, then valid.\r\n * @param _param unused\r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const notEmpty:RuleFunc = (_param, value) => {\r\n  if (typeOf(value) != 'string') return true\r\n  if (value !== '') return true\r\n  return {code:'rule.notEmpty'}\r\n}\r\n\r\n/**\r\n * Valid if `value` of Object has all properties specifed by `param`.\r\n * If `value` is not an Object, then valid.\r\n * @param param a list of property names\r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const required:RuleFunc = (param, value) => {\r\n  if (! Array.isArray(param)) throw new Error('invalid parameter')\r\n  if (typeOf(value) != 'object') return true\r\n  for (let i = 0; i < param.length; i++) {\r\n    if (! value.hasOwnProperty(param[i] as string)) return {code:'rule.required', hint:param[i] as string}\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Valid if `value` of Object is an instance of a tagged union specified by `param`\r\n * @example\r\n * ```javascript\r\n * param = {\r\n *   tagProperty: \"tag\", \r\n *   types: {\r\n *     leafOf: [\"value\"], \r\n *     nodeOf: [\"left\", \"right\"]\r\n *   }\r\n * }\r\n * switchRequired of `{tag:\"leafOf\", value:1}` evaludates valid.\r\n * switchRequired of `{tag:\"nodeOf\", left:otherNode}` evaluates invalid since `right` property is missing.\r\n * ```\r\n * @remark\r\n * We can use tagged unions by using the switchRequired rule.<br>\r\n * But notice, even if the property sets are different, if the property names \r\n * are the same, the schema will be the same.\r\n * @param param \r\n * @param value \r\n * @param lookup \r\n * @category Predefined Rules\r\n */\r\nexport const switchRequired:RuleFunc = (param, value, lookup) => {\r\n  if (typeOf(param) != 'object' || !('tagProperty' in (param as object))) throw new Error('invalid parameter')\r\n  if (typeOf(value) != 'object') return true\r\n  param = param as SwitchRequiredParam\r\n  const tag = lookup('0/' + param.tagProperty) as string\r\n  if (! tag) return {code:'rule.switchRequired.nohint', decription:'no tag'}\r\n  if (! param.types[tag]) return {code:'rule.switchRequired.nohint', detail:'no type'}\r\n  const required = param.types[tag]\r\n  if (! Array.isArray(required)) throw new Error('invalid parameter')\r\n  for (let i = 0; i < required.length; i++) {\r\n    if (! value.hasOwnProperty(required[i])) return {code:'rule.switchRequired', hint:required[i]}\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Valid if `value` is strictly equals to a value located in a path specified by `param`.\r\n * @param param path to the value to be compared\r\n * @param value \r\n * @param lookup \r\n * @category Predefined Rules\r\n */\r\nexport const same:RuleFunc = (param, value, lookup) => {\r\n  if (typeof param != 'string') throw new Error('invalid parameter')\r\n  const target = lookup(param)\r\n  if (target !== value) {\r\n    switch (typeOf(target)) {\r\n      case 'string': \r\n      case 'number': \r\n      case 'null': \r\n      case 'boolean': \r\n        return {code:'rule.same', hint: target as Scalar}\r\n      default: \r\n        return {code:'rule.same.nohint'}\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Valid if either of: \r\n * - {target} conforms the rules of {match}, and `value` conforms the rules of {then}.\r\n * - {target} doesn't conform the rules of {match}, and `value` conforms the rules of {else}.\r\n * Where `param` is an array of:\r\n * - {target} -- path to the target value\r\n * - {match} -- rules for target\r\n * - {then} -- rules of then clause\r\n * - {else} -- rules of else clause\r\n * @param param \r\n * @param value \r\n * @param lookup \r\n * @param rules \r\n * @category Predefined Rules\r\n */\r\nexport const $if:RuleFunc = (param, value, lookup, rules) => {\r\n  if (typeOf(param) != 'array') throw new Error('invalid parameter')\r\n  const param1 = param as IfParam\r\n  const [target, match, then, el = {}] = param1\r\n  if (! target || ! match || ! then) throw new Error('invalid parameter')\r\n  const targetValue = lookup(target)\r\n  const targetResult = applyRules(targetValue, match, lookup, rules)\r\n  if (targetResult === true) {\r\n    return applyRules(value, then, lookup, rules)\r\n  } else {\r\n    return applyRules(value, el, lookup, rules)\r\n  }\r\n}\r\n\r\n/**\r\n * Valid if `value`, where it is a number, is multiple of `param`.\r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const multipleOf:RuleFunc = (param, value) => {\r\n  if (typeof param != 'number') throw new Error('invalid parameter')\r\n  if (typeof value != 'number') return true\r\n  if (value % param === 0) return true\r\n  return {code:'rule.multipleOf', hint:param}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const maximum:RuleFunc = (param, value) => {\r\n  if (typeof value != 'number') return true\r\n  if (param >= value) return true\r\n  return {code:'rule.maximum', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const exclusiveMaximum:RuleFunc = (param, value) => {\r\n  if (typeof value != 'number') return true\r\n  if (param > value) return true\r\n  return {code:'rule.exclusiveMaximum', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const minimum:RuleFunc = (param, value) => {\r\n  if (typeof value != 'number') return true\r\n  if (param <= value) return true\r\n  return {code:'rule.minimum', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const exclusiveMinimum:RuleFunc = (param, value) => {\r\n  if (typeof value != 'number') return true\r\n  if (param < value) return true\r\n  return {code:'rule.exclusiveMinimum', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const maxLength:RuleFunc = (param, value) => {\r\n  if (typeof value != 'string') return true\r\n  if (value.length <= param) return true\r\n  return {code:'rule.maxLength', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const minLength:RuleFunc = (param, value) => {\r\n  if (typeof value != 'string') return true\r\n  if (value.length >= param) return true\r\n  return {code:'rule.minLength', hint:param as Scalar}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const pattern:RuleFunc = (param, value) => {\r\n  if (typeof param != 'string') throw new Error('invalid parameter')\r\n  if (typeof value != 'string') return true\r\n  if (new RegExp(param).test(value)) return true\r\n  return {code:'rule.pattern', hint: /** @type {string} */ (param)}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const maxItems:RuleFunc = (param, value) => {\r\n  if (typeof param != 'number') throw new Error('invalid parameter')\r\n  if (! Array.isArray(value)) return true\r\n  if (value.length <= param) return true\r\n  return {code:'rule.maxItems', hint: /** @type {number} */ (param)}\r\n}\r\n\r\n/**\r\n * \r\n * @param param \r\n * @param value \r\n * @category Predefined Rules\r\n */\r\nexport const minItems:RuleFunc = (param, value) => {\r\n  if (typeof param != 'number') throw new Error('invalid parameter')\r\n  if (! Array.isArray(value)) return true\r\n  if (value.length >= param) return true\r\n  return {code:'rule.minItems', hint: /** @type {number} */ (param)}\r\n}\r\n","/**\r\n * Data schema and validation\r\n * \r\n * @module core/schema\r\n */\r\n\r\nimport {typeOf, isJsonValue, appendPath} from './utils'\r\nimport {MgError, Scalar} from './errors'\r\nimport * as R from './rules'\r\n\r\n/**\r\n * Json array to silence tsc.\r\n * \r\n * @category Types\r\n */\r\nexport interface JsonArray extends Array<Json> {}\r\n\r\n/**\r\n * Json Object to silence tsc.\r\n * \r\n * @category Types\r\n */\r\nexport interface JsonObject extends Record<string,Json> {}\r\n\r\n/**\r\n * Simple Json type definition\r\n * \r\n * @category Types\r\n */\r\nexport type Json = null | number | string | boolean | JsonArray | JsonObject\r\n\r\n/**\r\n * Type of lookup function used in validation rules.\r\n * \r\n * @category Types\r\n */\r\nexport type Lookup = (path:string) => Json\r\n\r\n/**\r\n * Type of validation rule functions.<br>\r\n * They returns true if validation succeeded.<br>\r\n * Otherwise return MgError.\r\n * \r\n * @category Types\r\n */\r\nexport type RuleFunc = (param:Json, value:Json, lookup:Lookup, rules:Rules) => true|MgError\r\n\r\n/**\r\n * Named set of Rule functions.\r\n * \r\n * @category Types\r\n */\r\nexport type Rules = Record<string,RuleFunc>\r\n\r\n/**\r\n * The schema is modeled after JSON Schema.\r\n * \r\n * @category Types\r\n */\r\nexport type Schema = Record<string,Json>\r\n\r\n/**\r\n * Compiled schema.<br>\r\n * You can lookup a schema by a normalized path.\r\n * \r\n * @category Types\r\n */\r\nexport type SchemaDb = Record<string,Schema>\r\n\r\n/**\r\n * Slot is where metadata of each value of the model data comes. \r\n * \r\n * @category Types\r\n */\r\nexport type Slot = {\r\n  /**\r\n   * `true` if the value is invalid.\r\n   */\r\n  invalid?: boolean, \r\n  /**\r\n   * Non-null if the value has error.\r\n   */\r\n  error?: MgError, \r\n  /**\r\n   * `true` if the user changed this value.\r\n   */\r\n  touched?: boolean, \r\n  /**\r\n   * Raw string of user input.\r\n   */\r\n  input?: string, \r\n  /**\r\n   * the value itself of this value.\r\n   */\r\n  value?: Json\r\n}\r\n\r\n/**\r\n * Type of validation function.\r\n * \r\n * @category Types\r\n */\r\nexport type Validate = (value:any, slot0:Slot, schema:Schema, lookup:Lookup) => Slot\r\n\r\n\r\n/**\r\n * Returns true if type specification allows null.\r\n * \r\n * @category Entries\r\n */\r\nexport const nullable = (type:string):boolean => {\r\n  if (! type) return true\r\n  const lastChar = type.charAt(type.length - 1)\r\n  return type == 'null' || lastChar == '?'\r\n}\r\n\r\n/**\r\n * Builds a map from path to schema.\r\n * \r\n * @category Entries\r\n */\r\nexport const buildDb = (schema:Schema):SchemaDb => {\r\n  const db = /** @type SchemaDb */ ({})\r\n  const inner = (schema, path) => {\r\n    db[path] = schema\r\n    switch (schema.type) {\r\n      case 'object': \r\n      case 'object?': \r\n        for (let p in schema.properties) {\r\n          inner(schema.properties[p], path + '/' + p)\r\n        }\r\n        break\r\n      case 'array': \r\n      case 'array?': \r\n        inner(schema.items, path + '/*')\r\n        break\r\n      default: \r\n        break\r\n    }\r\n  }\r\n  inner(schema, \"\")\r\n  return db\r\n}\r\n\r\n/**\r\n * default validation rules.\r\n * Rules prefixed by '$' is registered by its true name. Use `defaultRules.if` instead of `defaultRules.$if`.\r\n * \r\n * @category Entries\r\n */\r\nexport const defaultRules:Rules = {\r\n  type:R.type, 'enum':R.$enum, 'const':R.$const, notEmpty:R.notEmpty, required:R.required, switchRequired:R.switchRequired, same:R.same, 'if':R.$if, \r\n  // TODO: allOf, eitherOf, not\r\n  multipleOf:R.multipleOf, maximum:R.maximum, exclusiveMaximum:R.exclusiveMaximum, minimum:R.minimum, exclusiveMinimum:R.exclusiveMinimum, maxLength:R.maxLength, minLength:R.minLength, pattern:R.pattern, maxItems:R.maxItems, minItems:R.minItems\r\n}\r\n\r\n/**\r\n * Validates a value with a schema. It is a shallow validation.\r\n * \r\n * @param rules set of validation rules, which means that you can add your own rules.\r\n * \r\n * @category Entries\r\n */\r\nexport const validate = (rules:Rules):Validate => (value, slot, schema, lookup) => {\r\n  if (! isJsonValue(value)) {\r\n    if (schema && schema.type) {\r\n      const error = {code:'type.'+schema.type, detail:'given value: '+value}\r\n      return {...slot, value, invalid:true, error}\r\n    } else {\r\n      const error = {code:'value', detail:'given value: '+value}\r\n      return {...slot, value, invalid:true, error}\r\n    }\r\n  }\r\n\r\n  if (schema) {\r\n    const result = applyRules(value, schema, lookup, rules)\r\n    if (result !== true) {\r\n      return {...slot, value, invalid:true, error:result}\r\n    }\r\n  }\r\n  return {...slot, value, invalid:false, error:null}\r\n}\r\n\r\n/**\r\n * \r\n * \r\n * \r\n * @category Entries\r\n */\r\nexport const applyRules = (value:any, schema:Schema, lookup:Lookup, rules:Rules):true|MgError => {\r\n  for (let p in schema) {\r\n    const f = rules[p]\r\n    if (! f) continue\r\n    const result = f(schema[p], value, lookup, rules)\r\n    if (result !== true) return result\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Executes coercion. Coercion is a process that interpretes a user input of string into a value of schema-specified type.\r\n * \r\n * @category Entries\r\n */\r\nexport const coerce = (input:string, slot:Slot, schema:Schema):Slot => {\r\n  input = \"\" + input  // coerce to string\r\n  if (! schema) {\r\n    throw new Error('coerce/0: no schema')\r\n  }\r\n  if (! schema.type || typeof schema.type != 'string') {\r\n    throw new Error('coerce/1: type not specified')\r\n  }\r\n  const type = schema.type\r\n  if (['null', 'boolean', 'boolean?', 'integer', 'integer?', 'number', 'number?', 'string'].indexOf(type) == -1) {\r\n    throw new Error('coerce/2: not a coercion enabled type: ' + type)\r\n  }\r\n\r\n  switch (type) {\r\n    case 'null': \r\n      break\r\n    case 'number': \r\n    case 'number?': \r\n      const n = +input\r\n      if (\"\" + n === input) {\r\n        return {value:n, input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'integer': \r\n    case 'integer?': \r\n      const i = +input\r\n      if (\"\" + i === input && i % 1 === 0) {\r\n        return {value:i, input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'boolean': \r\n    case 'boolean?': \r\n      if (input === \"true\" || input === \"false\") {\r\n        return {value:input===\"true\", input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'string': \r\n      return {value:input, input, touched:slot.touched}\r\n  }\r\n  if (input == \"\" && nullable(type)) {\r\n    return {value:null, input, touched:slot.touched}\r\n  }\r\n  return {input, touched:slot.touched}\r\n}\r\n\r\n\r\n","\r\nimport * as S from '../src/core/schema'\r\n\r\nexport const run = (assert, assertError, assertUndefined) => {\r\n  const v = S.validate(S.defaultRules)\r\n  const c = S.coerce\r\n\r\n  let s = null\r\n  let env = null\r\n\r\n  // type null\r\n  s = {type:'null'}\r\n  assert(1, () => v(null, {}, s).invalid, false)\r\n  assert(1.1, () => v(1, {}, s).invalid, true)\r\n  assert(1.2, () => v(\"abc\", {}, s).invalid, true)\r\n  assert(1.3, () => c(\"\", {}, s).value, null)\r\n  assertUndefined(1.4, () => c(\"abc\", {}, s).value)\r\n  assert(1.5, () => v(undefined, {}, s).invalid, true)\r\n\r\n  // no schema\r\n  s = null\r\n  assert(2, () => v(null, {}, s).invalid, false)\r\n  assert(2.1, () => v(10, {}, s).invalid, false)\r\n  assert(2.2, () => v([], {}, s).invalid, false)\r\n  assertError(2.3, () => c(\"\", {}, s), 'coerce/')\r\n  assertError(2.4, () => c(\"aaa\", {}, s), 'coerce/')\r\n  assert(2.5, () => v(undefined, {}, s).invalid, true)  // because `undefined' is not a JSON value\r\n\r\n  // type boolean\r\n  s = {type:'boolean'}\r\n  assert(3, () => v(null, {}, s).invalid, true)\r\n  assert(3.1, () => v(1, {}, s).invalid, true)\r\n  assert(3.2, () => v(true, {}, s).invalid, false)\r\n  assertUndefined(3.3, () => c('', {}, s).value)\r\n  assert(3.4, () => c('false', {}, s).value, false)\r\n  assertUndefined(3.5, () => c('abc', {}, s).value)\r\n  assert(3.6, () => c('true', {}, s).value, true)\r\n\r\n  // type boolean?\r\n  s = {type:'boolean?'}\r\n  assert(4, () => v(null, {}, s).invalid, false)\r\n  assert(4.1, () => v(1, {}, s).invalid, true)\r\n  assert(4.2, () => v(true, {}, s).invalid, false)\r\n  assert(4.3, () => c('', {}, s).value, null)\r\n  assert(4.4, () => c('false', {}, s).value, false)\r\n  assertUndefined(4.5, () => c('abc', {}, s).value)\r\n\r\n  // type integer\r\n  s = {type:'integer'}\r\n  assert(5, () => v(null, {}, s).invalid, true)\r\n  assert(5.1, () => v(1, {}, s).invalid, false)\r\n  assert(5.2, () => v(true, {}, s).invalid, true)\r\n  assertUndefined(5.3, () => c('', {}, s).value)\r\n  assert(5.4, () => c('10', {}, s).value, 10)\r\n  assertUndefined(5.5, () => c('abc', {}, s).value)\r\n  assert(5.6, () => v(132, {}, s).value, 132)\r\n\r\n  // type integer?\r\n  s = {type:'integer?'}\r\n  assert(6, () => v(null, {}, s).invalid, false)\r\n  assert(6.1, () => v(1, {}, s).invalid, false)\r\n  assert(6.2, () => v(true, {}, s).invalid, true)\r\n  assert(6.3, () => c('', {}, s).value, null)\r\n  assert(6.4, () => c('10', {}, s).value, 10)\r\n  assertUndefined(6.5, () => c('10.3', {}, s).value)\r\n  assert(6.6, () => c('132', {}, s).value, 132)\r\n\r\n  // type number\r\n  s = {type:'number'}\r\n  assert(7, () => v(null, {}, s).invalid, true)\r\n  assert(7.1, () => v(1.2, {}, s).invalid, false)\r\n  assert(7.2, () => v(true, {}, s).invalid, true)\r\n  assertUndefined(7.3, () => c('', {}, s).value)\r\n  assert(7.4, () => c('10.3', {}, s).value, 10.3)\r\n  assertUndefined(7.5, () => c('abc', {}, s).value)\r\n\r\n  // type number?\r\n  s = {type:'number?'}\r\n  assert(8, () => v(null, {}, s).invalid, false)\r\n  assert(8.1, () => v(1.2, {}, s).invalid, false)\r\n  assert(8.2, () => v(true, {}, s).invalid, true)\r\n  assert(8.3, () => c('', {}, s).value, null)\r\n  assert(8.4, () => c('10.3', {}, s).value, 10.3)\r\n  assertUndefined(8.5, () => c('abc', {}, s).value)\r\n\r\n  // type string\r\n  s = {type:'string'}\r\n  assert(9, () => v(null, {}, s).invalid, true)\r\n  assert(9.1, () => v('', {}, s).invalid, false)\r\n  assert(9.2, () => v(true, {}, s).invalid, true)\r\n  assert(9.3, () => v('abc', {}, s).invalid, false)\r\n  assert(9.4, () => c(\"\", {}, s).value, \"\")\r\n  assert(9.5, () => c(\"abc\", {}, s).value, \"abc\")\r\n\r\n  // type object\r\n  s = {type:'object'}\r\n  assert(10, () => v(null, {}, s).invalid, true)\r\n  assert(10.1, () => v('', {}, s).invalid, true)\r\n  assert(10.2, () => v({}, s).invalid, false)\r\n  assertError(10.3, () => c('', {}, s), 'coerce/')\r\n\r\n  // type object?\r\n  s = {type:'object?'}\r\n  assert(11, () => v(null, {}, s).invalid, false)\r\n  assert(11.1, () => v('', {}, s).invalid, true)\r\n  assert(11.2, () => v({}, {}, s).invalid, false)\r\n  assertError(11.3, () => c('', {}, s), 'coerce/')\r\n\r\n  // type array\r\n  s = {type:'array'}\r\n  assert(12, () => v(null, {}, s).invalid, true)\r\n  assert(12.1, () => v('', {}, s).invalid, true)\r\n  assert(12.2, () => v([], {}, s).invalid, false)\r\n  assertError(12.3, () => c('', {}, s), 'coerce/')\r\n\r\n  // type array?\r\n  s = {type:'array?'}\r\n  assert(13, () => v(null, {}, s).invalid, false)\r\n  assert(13.1, () => v('', {}, s).invalid, true)\r\n  assert(13.2, () => v([], {}, s).invalid, false)\r\n  assertError(13.3, () => c('', {}, s), 'coerce/')\r\n\r\n  // rule enum\r\n  s = {type:'integer?', enum:[1]}\r\n  assert(14, () => v(null, {}, s).invalid, true)\r\n  assert(14.1, () => v(1, {}, s).invalid, false)\r\n  assert(14.2, () => v(3, {}, s).invalid, true)\r\n\r\n  // rule const\r\n  s = {type:'number', 'const':3.2}\r\n  assert(15, () => v(3.2, {}, s).invalid, false)\r\n  assert(15.1, () => v(3, {}, s).invalid, true)\r\n\r\n  // rule required\r\n  s = {type:'object', required:['foo', 'bar']}\r\n  assert(16, () => v({foo:1, bar:1}, {}, s).invalid, false)\r\n  assert(16.1, () => v({foo:1}, {}, s).invalid, true)\r\n  assert(16.2, () => v({foo:1, bar:1, baz:1}, {}, s).invalid, false)\r\n  assert(16.3, () => v(1, {}, {...s, type:'integer'}).invalid, false)\r\n\r\n  // rule switchRequired\r\n  s = {\r\n    type:'object', \r\n    switchRequired: {\r\n      tagProperty: 'type', \r\n      types: {\r\n        infix: ['type', 'op', 'lhs', 'rhs'], \r\n        app: ['type', 'f', 'arg'], \r\n        var: ['type', 'var'], \r\n        lit: ['type', 'val'], \r\n        lambda: ['type', 'param', 'expr']\r\n      }\r\n    }\r\n  }\r\n  let data = {type:'infix', op:'*', lhs:{type:'var', var:'n'}, rhs:{type:'app', f:'fact', arg:{type:'infix', op:'-', lhs:{type:'var', var:'n'}, rhs:{type:'lit'}}}}  // n * fact(n - 1)\r\n  assert(17, () => v(data, {}, s, (path) => 'infix').invalid, false)\r\n  assert(17.1, () => v(data.lhs, {}, s, (path) => 'var').invalid, false)\r\n  assert(17.2, () => v(data.rhs.arg.rhs, {}, s, (path) => 'lit').invalid, true)\r\n  assert(17.3, () => v(1, {}, {...s, type:'integer'}).invalid, false)\r\n\r\n  // rule multipleOf\r\n  s = {type:'number?', multipleOf:1.2}\r\n  assert(18, () => v(-2.4, {}, s).invalid, false)\r\n  assert(18.1, () => v(1.5, {}, s).invalid, true)\r\n  assert(18.2, () => v(null, {}, s).invalid, false)\r\n  assert(18.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule maximum\r\n  s = {type:'integer?', maximum:10}\r\n  assert(19, () => v(10, {}, s).invalid, false)\r\n  assert(19.1, () => v(11, {}, s).invalid, true)\r\n  assert(19.2, () => v(null, {}, s).invalid, false)\r\n  assert(19.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule exclusiveMaximum\r\n  s = {type:'integer?', exclusiveMaximum:10}\r\n  assert(20, () => v(9, {}, s).invalid, false)\r\n  assert(20.1, () => v(10, {}, s).invalid, true)\r\n  assert(20.2, () => v(null, {}, s).invalid, false)\r\n  assert(20.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule minimum\r\n  s = {type:'integer?', minimum:10}\r\n  assert(21, () => v(10, {}, s).invalid, false)\r\n  assert(21.1, () => v(9, {}, s).invalid, true)\r\n  assert(21.2, () => v(null, {}, s).invalid, false)\r\n  assert(21.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule exclusiveMinimum\r\n  s = {type:'integer?', exclusiveMinimum:10}\r\n  assert(20, () => v(10, {}, s).invalid, true)\r\n  assert(20.1, () => v(11, {}, s).invalid, false)\r\n  assert(20.2, () => v(null, {}, s).invalid, false)\r\n  assert(20.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule maxLength\r\n  s = {type:'string', maxLength:3}\r\n  assert(21, () => v('abc', {}, s).invalid, false)\r\n  assert(21.1, () => v('abcd', {}, s).invalid, true)\r\n  assert(21.2, () => v('', {}, s).invalid, false)\r\n  assert(21.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule minLength\r\n  s = {type:'string', minLength:3}\r\n  assert(21, () => v('abd', {}, s).invalid, false)\r\n  assert(21.1, () => v('ab', {}, s).invalid, true)\r\n  assert(21.2, () => v('', {}, s).invalid, true)\r\n  assert(21.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n  \r\n  // rule pattern\r\n  s = {type:'string', pattern:\"^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$\"}\r\n  assert(22, () => v('info@example.com', {}, s).invalid, false)\r\n  assert(22.1, () => v('192.168.0.1', {}, s).invalid, true)\r\n  assert(22.2, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule maxItems\r\n  s = {type:'array?', maxItems:3}\r\n  assert(23, () => v([1,2,3], {}, s).invalid, false)\r\n  assert(23.1, () => v([1,2,3,4], {}, s).invalid, true)\r\n  assert(23.2, () => v(null, {}, s).invalid, false)\r\n  assert(23.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule minItems\r\n  s = {type:'array?', minItems:4}\r\n  assert(24, () => v([1,2,3], {}, s).invalid, true)\r\n  assert(24.1, () => v([1,2,3,4], {}, s).invalid, false)\r\n  assert(24.2, () => v(null, {}, s).invalid, false)\r\n  assert(24.3, () => v(true, {}, {...s, type:'boolean'}).invalid, false)\r\n\r\n  // rule same\r\n  s = {type:'string',same:'/first'}\r\n  data = {first:'a', second:'a'}\r\n  assert(25, () => v('a', {}, s, (path) => 'a').invalid, false)\r\n  assert(25.1, () => v('b', {}, s, (path) => 'a').invalid, true)\r\n  s = {same:'/first'}\r\n  assert(25.2, () => v('a', {}, s, (path) => 'a').invalid, false)\r\n\r\n  // rule conditional\r\n  s = {\r\n    type:'object?', \r\n    properties: {\r\n      at: {type:'string'}, \r\n      to: {type:'string'}\r\n    }, \r\n    required:['at', 'to'], \r\n    if: ['/status', {enum:['shipped', 'refunded']}, {type:'object'}]\r\n  }\r\n  assert(26, () => v(null, {}, s, (path) => 'new', S.defaultRules).invalid, false)\r\n  assert(26.1, () => v(null, {}, s, (path) => 'shipped', S.defaultRules).invalid, true)\r\n  assert(26.2, () => v({at:'a',to:'b'}, {}, s, (path) => 'new', S.defaultRules).invalid, false)\r\n  assert(26.3, () => v({at:'a',to:'b'}, {}, s, (path) => 'shipped', S.defaultRules).invalid, false)\r\n  s = {\r\n    type:'object?', \r\n    properties: {\r\n      at: {type:'string'}, \r\n      to: {type:'string'}\r\n    }, \r\n    required:['at', 'to'], \r\n    if: ['/status', {enum:['shipped', 'refunded']}, {type:'object'}, {type:'null'}]\r\n  }\r\n  assert(26.4, () => v(null, {}, s, (path) => 'new', S.defaultRules).invalid, false)\r\n  assert(26.5, () => v(null, {}, s, (path) => 'shipped', S.defaultRules).invalid, true)\r\n  assert(26.6, () => v({at:'a',to:'b'}, {}, s, (path) => 'new', S.defaultRules).invalid, true)\r\n  assert(26.7, () => v({at:'a',to:'b'}, {}, s, (path) => 'shipped', S.defaultRules).invalid, false)\r\n\r\n  /*s = {\r\n    type:'object?', \r\n    properties: {\r\n      at: {type:'string'}, \r\n      to: {type:'string'}\r\n    }, \r\n    required:['at', 'to'], \r\n    allOf: [\r\n      {conditional: ['/status', {enum:['shipped', 'refunded']}, {type:'object'}]}, \r\n      {conditional: ['/status', {not:{enum:['shipped', 'refunded']}}, {type:'null'}]}\r\n    ]\r\n  }*/\r\n}","\r\nimport * as U from './utils'\r\nimport * as E from './env'\r\nimport * as S from './schema'\r\n\r\nconst assert = (ident, thunk, rv) => {\r\n  const lv = thunk()\r\n  if (lv == rv) {\r\n    console.log('- ASSERTION', ident, 'OK')\r\n  } else {\r\n    console.log('! ASSERTION', ident, 'NG', lv, rv)\r\n  }\r\n}\r\n\r\nconst assertUndefined = (ident, thunk) => {\r\n  const lv = thunk()\r\n  if (typeof lv == \"undefined\") {\r\n    console.log('- ASSERTION', ident, 'OK')\r\n  } else {\r\n    console.log('! ASSERTION', ident, 'NG', lv, \"undefined\")\r\n  }\r\n}\r\n\r\nconst assertError = (ident, thunk, match) => {\r\n  let status = null\r\n  try {\r\n    const lv = thunk()\r\n    status = \"no error\"\r\n  } catch (e) {\r\n    if (e instanceof Error && e.message.startsWith(match)) {\r\n      console.log('- ASSERTION', ident, 'OK')\r\n      return\r\n    } else {\r\n      status = \"matching failure: \" + e.message\r\n    }\r\n  }\r\n  console.log('! ASSERTION', ident, 'NG', status)\r\n}\r\n\r\nconst callRun = (m, name) => {\r\n  console.log('TEST START: ' + name)\r\n  m.run(assert, assertError, assertUndefined)\r\n  console.log('TEST DONE: ' + name)\r\n  console.log('')\r\n}\r\n\r\ncallRun(U, 'utils')\r\ncallRun(E, 'env')\r\ncallRun(S, 'schema')"]}