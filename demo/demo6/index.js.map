{"version":3,"sources":["../../src/core/utils.ts","../../src/core/env.ts","../../src/core/schema.ts","../../src/core/errors.ts","../../src/core/framework.ts","src.js"],"names":["master","frame","name","price","os","cpu","memory","accessory","bonus","schema","type","properties","detail","notEmpty","accessories","reduce","cur","a","i","flags","isPro","bigDeal","quotation","lines","items","category","description","unitPrice","quantity","amount","subtotal","tax","total","data","findByProp","value","lis","length","evolve","env","path","prevEnv","addLine","x","line","API","add","extract","forEach","remove","touchAll","validate","numErrors","countValidationErrors","console","error","tree","result","log"],"mappings":"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","file":"index.js","sourceRoot":"","sourcesContent":["//@ts-check\r\n/** @module core/utils */\r\n\r\nexport type Index = string|number\r\n\r\n/**\r\n * Returns true if x is an string representation of an integer value.\r\n * @function\r\n * @param {any} x\r\n * @returns {boolean} \r\n */\r\nexport const isIntStr = (x:any):boolean => {\r\n  const n = +x\r\n  return (n % 1 === 0 && x === \"\" + n)\r\n}\r\n\r\n/**\r\n * Returns the array-index independent normalized path.\r\n * @function\r\n * @param {string} path \r\n * @returns {string}\r\n */\r\nexport const normalizePath = (path:string):string => {\r\n  const frags = path.split('/')\r\n  for (let i = 1; i < frags.length; i++) {\r\n    if (isIntStr(frags[i])) {\r\n      frags[i] = '*'\r\n    }\r\n  }\r\n  return frags.join('/')\r\n}\r\n\r\n/**\r\n * Concatenates two pathes, `path' can be a relative one.\r\n * @function\r\n * @param {string} base \r\n * @param {string} path \r\n * @returns {string}\r\n */\r\nexport const appendPath = (base:string, path:string):string => {\r\n  if (path.charAt(0) == '' || path.charAt(0) == '/') return path  // absolute path\r\n  if (path === '0') return base  // easy frequent case\r\n  \r\n  const base1 = pathToArray(base)\r\n  let frag0 = path.split('/')\r\n  let frag = []\r\n  let unused = null\r\n\r\n  let upcount = +frag0[0]\r\n  frag = base1\r\n  if (upcount > frag.length) {\r\n    upcount = frag.length\r\n  }\r\n  frag.splice(frag.length - upcount, upcount)\r\n\r\n  frag0.shift()\r\n\r\n  if (frag0.length == 0 && frag.length == 0) return ''\r\n  return '/' + frag.concat(frag0).join('/')\r\n}\r\n\r\n/**\r\n * Normalizes not a string path but an array path, then returns a normalized string path.\r\n * @function\r\n * @param {Index[]} path\r\n * @returns {string} \r\n */\r\nexport const normalizePathArray = (path:Index[]):string => {\r\n  let rv = ''\r\n  for (let i = 0; i < path.length; i++) {\r\n    if (typeof path[i] == 'number' || isIntStr(path[i])) {\r\n      rv += '/*'\r\n    } else {\r\n      rv += '/' + path[i]\r\n    }\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * Separates a path described by a string into an Index array.\r\n * @function\r\n * @param {string} path \r\n * @returns {Index[]}\r\n */\r\nexport const pathToArray = (path:string):Index[] => {\r\n  const frags = path.split('/')\r\n  const rv = []\r\n  for (let i = 1; i < frags.length; i++) {\r\n    rv.push(isIntStr(frags[i]) ? +frags[i] : frags[i])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * A variant of `typeof', which handles null and Array appropreately.\r\n * @function\r\n * @param {null|array|object|boolean|number|string} x \r\n * @returns {string}\r\n */\r\nexport const typeOf = (x:any):string => x === null ? 'null' : Array.isArray(x) ? 'array' : typeof x\r\n\r\n/**\r\n * Empty object.\r\n * @type {{}}\r\n */\r\nexport const emptyObject:{} = {}\r\n\r\n/**\r\n * Empty Array.\r\n * @template T\r\n * @type {T[]}\r\n */\r\nexport const emptyArray:[] = []\r\n\r\n/**\r\n * Returns true if `x' is a json value.\r\n * @function\r\n * @param {any} x\r\n * @returns {boolean} \r\n */\r\nexport const isJsonValue = (x:any):boolean => {\r\n  switch (typeOf(x)) {\r\n    case 'null': \r\n    case 'number': \r\n    case 'boolean': \r\n    case 'string': \r\n    case 'object': \r\n    case 'array': \r\n      return true\r\n    default: \r\n      return false\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts common portion of pathes.\r\n * @function\r\n * @param {string} path1 \r\n * @param {string} path2 \r\n * @return {string}\r\n */\r\nexport const commonPath = (path1:string, path2:string):string => {\r\n  const frags1 = path1.split('/')\r\n  const frags2 = path2.split('/')\r\n  const rv = []\r\n  for (let i = 0; i < frags1.length; i++) {\r\n    if (frags2.length <= i) break\r\n    if (frags1[i] != frags2[i]) break\r\n    rv.push(frags1[i])\r\n  }\r\n  return rv.join('/')\r\n}\r\n\r\n/**\r\n * Builds a query string from `obj'.\r\n * @function\r\n * @param {Object} obj \r\n * @param {boolean} omitEmptyParam \r\n * @returns {Record<string, string>}\r\n */\r\nexport const normalizeQuery = (obj:Record<string,string>, omitEmptyParam:boolean):Record<string,string> => {\r\n  const rv = /** @type {Record<string, string>} */ ({})\r\n  for (let p in obj) {\r\n    switch (typeOf(p)) {\r\n      case 'null': \r\n        if (!omitEmptyParam) rv[p] = ''\r\n        break\r\n      case 'boolean': \r\n        rv[p] = obj[p] ? 'true' : 'false'\r\n        break\r\n      case 'number': \r\n        rv[p] = \"\" + obj[p]\r\n        break\r\n      case 'string': \r\n        if (omitEmptyParam && obj[p] === \"\") break\r\n        rv[p] = obj[p]\r\n        break\r\n    }\r\n  }\r\n  return rv\r\n}","//@ts-check\r\n/** @module core/env */\r\n\r\nimport {normalizePath, typeOf, isIntStr, normalizePathArray, appendPath, Index} from './utils'\r\nimport {hasPath as rhasPath, init, path as rpath, assocPath, insert, last, dissoc, remove as rremove, update } from 'ramda'\r\nimport {Json, Schema, Slot, SchemaDb, Lookup, Validate} from './schema'\r\n\r\ntype MutateSlot = (slot:Slot, path:string) => Slot\r\ntype ReduceSlot<T> = (cur:T, slot:Slot, path:string) => T\r\n\r\nexport interface Env {\r\n  tree: Json, \r\n  trackUpdate: boolean, \r\n  updatePoint: Index[], \r\n  schemaDb: SchemaDb, \r\n  validate: Validate, \r\n  extra: Record<string,any>, \r\n  ret?: any, \r\n  onPromiseThen?: any\r\n}\r\n\r\n\r\n/**\r\n * see: https://github.com/ramda/ramda/pull/2841\r\n * Anyway, here we fix the original behavior.\r\n * @function\r\n * @private\r\n * @param {string[]} path \r\n * @param {any} x \r\n * @return {boolean}\r\n */\r\nconst hasPath = (path:Index[], x:any):boolean => {\r\n  if (! path.length) return true\r\n  return rhasPath(path as string[], x)\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n */\r\nconst init2 = <T>(list:T[]) => {\r\n  return init(init(list))\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} value \r\n * @return {Slot} \r\n */\r\nconst makeSlot = (value:Json):Slot => {\r\n  const rv:Slot = {value, invalid:false, error:null}\r\n  switch (typeOf(value)) {\r\n    case 'object': // FALLTHRU\r\n    case 'array': \r\n      break\r\n    case 'number': // FALLTHRU\r\n    case 'integer': \r\n      rv.input = '' + value\r\n      rv.touched = false\r\n      break\r\n    case 'boolean': \r\n      rv.input = (value) ? 'true' : 'false'\r\n      rv.touched = false\r\n      break\r\n    case 'null': \r\n      rv.input = ''\r\n      rv.touched = false\r\n      break\r\n    case 'string': \r\n      rv.input = value as string\r\n      rv.touched = false\r\n      break\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} data \r\n * @returns {Slot}\r\n */\r\nconst wrap = (data):Slot => {\r\n  /** @type {(data:Json) => Slot} */\r\n  const inner = (data:Json):Slot => {\r\n    switch (typeOf(data)) {\r\n      case 'array': \r\n        const es = []\r\n        for (let i = 0; i < (data as Json[]).length; i++) {\r\n          es[i] = inner(data[i])\r\n        }\r\n        return makeSlot(es)\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in (data as Object)) {\r\n          rec[p] = inner(data[p])\r\n        }\r\n        return makeSlot(rec)\r\n      default: \r\n        return makeSlot(data)\r\n    }\r\n  }\r\n  return inner(data)\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {Json} tree \r\n * @returns {Json}\r\n */\r\nconst strip = (tree:Json):Json => {\r\n  const root = (tree as Slot).value\r\n  switch (typeOf(root)) {\r\n    case 'array': \r\n      const es = []\r\n      for (let i = 0; i < (root as Json[]).length; i++) {\r\n        es[i] = strip(root[i])\r\n      }\r\n      return es\r\n    case 'object': \r\n      const rec = {}\r\n      for (let p in (root as Object)) {\r\n        rec[p] = strip(root[p])\r\n      }\r\n      return rec\r\n    default: \r\n      return root\r\n  }\r\n}\r\n\r\n/**\r\n * Makes env.\r\n * @function\r\n * @param {Json} data \r\n * @param {SchemaDb} schemaDb \r\n * @param {ValidateFunc} validate\r\n * @param {boolean} trackUpdate\r\n * @returns {Env}\r\n */\r\nexport const makeEnv = (data:Json, schemaDb:SchemaDb, validate:Validate, trackUpdate:boolean):Env => {\r\n  const tree = wrap(data) as Json\r\n  return {\r\n    tree, \r\n    trackUpdate, \r\n    updatePoint: trackUpdate ? [] : null, \r\n    schemaDb, \r\n    validate, \r\n    extra: {}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env0 \r\n * @param {Env} env1 \r\n * @returns {boolean}\r\n */\r\nexport const isSame = (env0:Env, env1:Env):boolean => {\r\n  return (env0.tree === env1.tree && env0.extra === env1.extra)\r\n}\r\n\r\n/**\r\n * Internalizes a path\r\n * @function\r\n * @private\r\n * @param {string} path \r\n * @returns {(string|number)[]}\r\n */\r\nconst internPath = (path:string):Index[] => {\r\n  const frags = path.split('/')\r\n  const rv = []\r\n  for (let i = 1; i < frags.length; i++) {\r\n    rv.push('value')\r\n    rv.push(isIntStr(frags[i]) ? +frags[i] : frags[i])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {(string|number)[]} path \r\n * @returns {string}\r\n */\r\nconst externPath = (path:Index[]):string => {\r\n  let rv = \"\"\r\n  for (let i = 0; i < path.length; i += 2) {\r\n    rv += \"/\" + path[i + 1]\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @private\r\n * @param {((string|number)[])|null} path0 \r\n * @param {((string|number)[])|null} path1\r\n * @returns {((string|number)[])|null} \r\n */\r\nconst intersect = (path0:Index[]|null, path1:Index[]|null):Index[]|null => {\r\n  if (path0 === null) return path1\r\n  if (path1 === null) return path0\r\n\r\n  const rv = []\r\n  for (let i = 0; i < path0.length; i += 2) {\r\n    if (i >= path1.length) break\r\n    if (path0[i + 1] !== path1[i + 1]) break\r\n    rv.push(path0[i])\r\n    rv.push(path0[i + 1])\r\n  }\r\n  return rv\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const beginUpdateTracking = (env:Env):Env => {\r\n  // Essentially, `updatePoint' should be set to null, but it can be omitted \r\n  // because the value when disabled is null.\r\n  return {...env, trackUpdate:true}\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env \r\n * @returns {[string|null, Env]}\r\n */\r\nexport const endUpdateTracking = (env:Env):[string|null, Env] => {\r\n  const updatePoint = env.updatePoint ? externPath(env.updatePoint) : null\r\n  console.log('update occurred at ' + JSON.stringify(updatePoint))\r\n  return [\r\n    updatePoint, \r\n    {...env, trackUpdate:false, updatePoint:null}\r\n  ]\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {boolean}\r\n */\r\nexport const test = (path:string, env:Env):boolean => {\r\n  return hasPath(/** @type {string[]} */ (internPath(path)), env.tree)\r\n}\r\n\r\n/**\r\n * Extracts a subtree of Env.\r\n * @function\r\n * @param {string} path\r\n * @param {Env} env\r\n * @returns {Json}\r\n */\r\nexport const extract = (path:string, env:Env):Json => {\r\n  const epath = /** @type {string[]} */ (internPath(path))\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('extract/1: not found: ' + path)\r\n  }\r\n  return strip(slot as Json)\r\n}\r\n\r\n/**\r\n * Low-level api.\r\n * @function\r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Slot} \r\n */\r\nexport const getSlot = (path:string, env:Env):Slot => {\r\n  const epath = /** @type {string[]} */ (internPath(path))\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('getSlot/1: not found: ' + path)\r\n  }\r\n  return slot\r\n}\r\n\r\n/**\r\n * Low-level api. This function executes neither validation nor coercion.\r\n * @function\r\n * @param {string} path \r\n * @param {Slot} slot \r\n * @param {Env} env\r\n * @returns {Env} \r\n * \r\n * slot value must be a scalar.\r\n */\r\nexport const setSlot = (path:string, slot:Slot, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree) as Slot\r\n  if (! slot0) {\r\n    throw new Error('setSlot/1: not found: ' + path)\r\n  }\r\n  switch (typeOf(slot0.value)) {\r\n    case 'null': \r\n    case 'boolean': \r\n    case 'number': \r\n    case 'string': \r\n    case 'undefined': \r\n      break\r\n    default: \r\n      throw new Error('setSlot/2: not a scalar: ' + path)\r\n  }\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n  return {...env, tree, updatePoint}\r\n}\r\n\r\n/**\r\n * Adds value to env. `add' function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Json} value \r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const add = (path:string, value:Json, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('add/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // insert into array\r\n    const index = (name === '-') ? (slot0.value as Json[]).length : name\r\n    if (typeof index != 'number' || index % 1 !== 0) {\r\n      throw new Error('add/2 invalid index: ' + path)\r\n    }\r\n    if (index < 0 || index > (slot0.value as Json[]).length) {\r\n      throw new Error('add/3 index out of range: ' + path)\r\n    }\r\n    const value1 = wrap(value) as Json\r\n    const lis = insert(index, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    // Insertion to a list is an update not to an item but to the list.\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // define or replace into object\r\n    if (typeof name != 'string') {\r\n      throw new Error('add/4 invalid name: ' + path)\r\n    }\r\n    const value1 = wrap(value)\r\n    const rec = {...(slot0.value as {[prop:string]:Json}), [name]:value1} as Json\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    // Adding a property is an update to an object, while replacing a property is an update to an property value.\r\n    const updatePoint = !env.trackUpdate ? env.updatePoint \r\n      : intersect(env.updatePoint, (name in (slot0.value as Object)) ? epath : location)\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Removes a value specified by path from env. `remove' function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const remove = (path:string, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('remove/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // removes from array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('remove/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('remove/3 out of range: ' + path)\r\n    }\r\n    const lis = rremove(name, 1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // delete property from object\r\n    if (! slot0.value.hasOwnProperty(name)) {\r\n      throw new Error('remove/4: property not found: ' + path)\r\n    }\r\n    const rec = dissoc(name as never, slot0.value as object)\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, location) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Replaces a value specified by path into value.  Implements replace function of JSON patch.\r\n * @function\r\n * @param {string} path \r\n * @param {Json} value \r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const replace = (path:string, value:Json, env:Env):Env => {\r\n  const epath = internPath(path)\r\n  if (epath.length == 0) {\r\n    // replace whole data\r\n    const tree = wrap(value) as Json\r\n    const updatePoint = env.trackUpdate ? [] : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, env.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('replace/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // replace an element in array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('replace/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('replace/3 out of range: ' + path)\r\n    }\r\n    const value1 = wrap(value) as Json\r\n    const lis = update(name, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  } else {\r\n    // replace a property of object\r\n    if (typeof name != 'string') {\r\n      throw new Error('replace/4 invalid name: ' + path)\r\n    }\r\n    if (!(name in (slot0.value as {[prop:string]:Json}))) {\r\n      throw new Error('replace/5 undefined property: ' + path)\r\n    }\r\n    const value1 = wrap(value)\r\n    const rec = {...(slot0.value as {[prop:string]:Json}), [name]:value1} as {[prop:string]:Json}\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, env.tree)\r\n    const updatePoint = env.trackUpdate ? intersect(env.updatePoint, epath) : env.updatePoint\r\n    return {...env, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * Moves a value located in from, to a location specified by path.  Implements move function of JSON patch.\r\n * @function\r\n * @param {string} from \r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n */\r\nexport const move = (from:string, path:string, env:Env):Env => {\r\n  const value = extract(from, env)\r\n  env = remove(from, env)\r\n  env = add(path, value, env)\r\n  return env\r\n}\r\n\r\n/**\r\n * Copies a value located in from, to a location specified by path.  Impelementing copy function of JSON patch.\r\n * @function\r\n * @param {string} from \r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n */\r\nexport const copy = (from:string, path:string, env:Env):Env => {\r\n  const value = extract(from, env)\r\n  env = add(path, value, env)\r\n  return env\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} path \r\n * @param {Env} env\r\n * @returns {Env} \r\n */\r\nexport const validate = (path:string, env:Env):Env => {\r\n  let basePath = null\r\n\r\n  /**\r\n   * \r\n   * @param {string} path \r\n   * @returns {Json}\r\n   */\r\n  const lookup = (path) => {\r\n    const pathToLookup = appendPath(basePath, path)\r\n    return extract(pathToLookup, env)\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {Slot} slot0 \r\n   * @param {string} npath\r\n   * @param {string} path\r\n   * @returns {Slot} \r\n   */\r\n  const inner = (slot0:Slot, npath:string, path:string):Slot => {\r\n    const value0 = slot0.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        const lis = []\r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          lis[i] = inner(value0[i], npath + '/*', path + '/' + i)\r\n        }\r\n        basePath = path\r\n        return env.validate(lis, slot0, env.schemaDb[npath], lookup)\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in  (value0 as Record<string,Json>)) {\r\n          rec[p] = inner(value0[p], npath + '/' + p, path + '/' + p)\r\n        }\r\n        basePath = path\r\n        return env.validate(rec, slot0, env.schemaDb[npath], lookup)\r\n      default: \r\n        basePath = path\r\n        const slot = env.validate(value0, slot0, env.schemaDb[npath], lookup)\r\n        if (slot.value !== value0) {\r\n          throw new Error('validate/0: value changed: ' + path)\r\n        }\r\n        return slot\r\n    }\r\n  }\r\n\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree)\r\n  if (! slot0) {\r\n    throw new Error('validate/1: not found: ' + path)\r\n  }\r\n  const slot = inner(slot0, normalizePath(path), path)\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  return {...env, tree}\r\n}\r\n\r\n/**\r\n * By f, maps every slot descending to a location specified by path.\r\n * @function\r\n * @param {MutateSlotFunc} f \r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const mapDeep = (f:MutateSlot, path:string, env:Env):Env => {\r\n  const inner = (slot0:Slot, path:string):Slot => {\r\n    const value0 = slot0.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        const lis = []\r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          lis[i] = inner(value0[i], path + '/' + i)\r\n        }\r\n        return {...f(slot0, path), value:lis}\r\n      case 'object': \r\n        const rec = {}\r\n        for (let p in (value0 as Record<string,Json>)) {\r\n          rec[p] = inner(value0[p], path + '/' + p)\r\n        }\r\n        return {...f(slot0, path), value:rec}\r\n      default: \r\n        return {...f(slot0, path), value:value0}\r\n    }\r\n  }\r\n  const epath = internPath(path)\r\n  const slot0 = rpath(epath, env.tree)\r\n  if (! slot0) {\r\n    throw new Error('mapDeep/1: not found: ' + path)\r\n  }\r\n  const slot = inner(slot0, path)\r\n  const tree = assocPath(epath, slot, env.tree)\r\n  return {...env, tree}\r\n}\r\n\r\n/**\r\n * By f, deeply reduces a subtree of path.\r\n * @function\r\n * @template T\r\n * @param {ReduceSlotFunc<T>} f \r\n * @param {T} cur \r\n * @param {string} path \r\n * @param {Env} env \r\n * @returns {T}\r\n */\r\nexport const reduceDeep = <T>(f:ReduceSlot<T>, cur:T, path:string, env:Env):T => {\r\n  const inner = (cur:T, slot:Slot, path:string):T => {\r\n    const value0 = slot.value\r\n    switch (typeOf(value0)) {\r\n      case 'array': \r\n        for (let i = 0; i < (value0 as Json[]).length; i++) {\r\n          cur = inner(cur, value0[i], path + '/' + i)\r\n        }\r\n        return f(cur, slot, path)\r\n      case 'object': \r\n        for (let p in (value0 as Record<string,Json>)) {\r\n          cur = inner(cur, value0[p], path + '/' + p)\r\n        }\r\n        return f(cur, slot, path)\r\n      default: \r\n        return f(cur, slot, path)\r\n    }\r\n  }\r\n  const epath = internPath(path)\r\n  const slot = rpath(epath, env.tree)\r\n  if (! slot) {\r\n    throw new Error('reduceDeep/1: not found: ' + path)\r\n  }\r\n  return inner(cur, slot, path)\r\n}\r\n\r\nexport const duplicate = (path:string, fromEnv:Env, toEnv:Env):Env => {\r\n  const epath = internPath(path)\r\n  if (epath.length == 0) {\r\n    // duplicate whole data\r\n    const tree = fromEnv.tree\r\n    const updatePoint = toEnv.trackUpdate ? [] : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  }\r\n  const location = init2(epath)\r\n  const name = last(epath)\r\n  const slot0 = rpath(location, fromEnv.tree) as Slot\r\n  const type0 = typeOf(slot0.value)\r\n  if (type0 != 'object' && type0 != 'array') {\r\n    throw new Error('duplicate/1 neither an object nor an array: ' + path)\r\n  }\r\n  if (type0 == 'array') {\r\n    // duplicate an element in an array\r\n    if (typeof name != 'number' || name % 1 !== 0) {\r\n      throw new Error('duplicate/2 invalid index: ' + path)\r\n    }\r\n    if (name < 0 || name >= (slot0.value as Json[]).length) {\r\n      throw new Error('duplicate/3 out of range: ' + path)\r\n    }\r\n    const value1 = slot0.value[name]\r\n    const lis = update(name, value1, slot0.value as Json[])\r\n    const slot = makeSlot(lis)\r\n    const tree = assocPath(location, slot, toEnv.tree)\r\n    const updatePoint = toEnv.trackUpdate ? intersect(toEnv.updatePoint, epath) : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  } else {\r\n    // duplicate a property of an object\r\n    if (typeof name != 'string') {\r\n      throw new Error('replace/4 invalid name: ' + path)\r\n    }\r\n    if (!(name in (slot0.value as Record<string,Json>))) {\r\n      throw new Error('replace/5 undefined property: ' + path)\r\n    }\r\n    const value1 = slot0.value[name]\r\n    const rec = {...(slot0.value as Record<string,Json>), [name]:value1}\r\n    const slot = makeSlot(rec)\r\n    const tree = assocPath(location, slot, toEnv.tree)\r\n    const updatePoint = toEnv.trackUpdate ? intersect(toEnv.updatePoint, epath) : toEnv.updatePoint\r\n    return {...toEnv, tree, updatePoint}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} name \r\n * @param {Object|null} info \r\n * @param {Env} env\r\n * @returns {Env} \r\n */\r\nexport const setExtra = (name:string, info:Object|null, env:Env):Env => {\r\n  if (info === null) {\r\n    const {[name]:_unused, ...extra} = env.extra\r\n    return {...env, extra}\r\n  } else {\r\n    const extra = {...env.extra, [name]:info}\r\n    return {...env, extra}\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} name \r\n * @param {Env} env\r\n * @returns {Object|null} \r\n */\r\nexport const getExtra = (name:string, env:Env):Object|null => {\r\n  return env.extra[name] || null\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {any} ret \r\n * @param {any} onPromiseThen\r\n * @param {Env} env \r\n * @returns {Env}\r\n */\r\nexport const setPortal = (ret:any, onPromiseThen:any, env:Env):Env => {\r\n  if (ret) return {...env, ret, onPromiseThen}\r\n  const {ret:_unused, onPromiseThen:_unused2, ...env2} = env\r\n  return env2\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Env} env\r\n * @returns {void} \r\n */\r\nexport const doReturn = (env:Env):void => {\r\n  if (env.ret) {\r\n    env.ret(env)\r\n  } else {\r\n    throw new Error('doReturn/0: no ret')\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {any} x\r\n * @returns {boolean} \r\n */\r\nexport const isEnv = (x:any):boolean => {\r\n  return (x != null \r\n    && typeof x == \"object\" \r\n    && \"tree\" in x)\r\n}","//@ts-check\r\n/** @module core/schema */\r\n\r\nimport {emptyObject, typeOf, isJsonValue, appendPath} from './utils'\r\nimport {MgError, Scalar} from './errors'\r\n\r\nexport type Json = null | number | string | boolean | Json[] | {[prop:string]:Json}\r\nexport type Lookup = (path:string) => Json\r\nexport type Rules = Record<string,RuleFunc>\r\nexport type RuleFunc = (param:Json, value:Json, lookup:Lookup, rules:Rules) => true|MgError\r\nexport type Schema = Record<string,Json>\r\nexport type SchemaDb = Record<string,Schema>\r\n\r\nexport interface Slot {\r\n  invalid?: boolean, \r\n  error?: MgError, \r\n  touched?: boolean, \r\n  input?: string, \r\n  value?: Json\r\n}\r\n\r\nexport type Validate = (value:any, slot0:Slot, schema:Schema, lookup:Lookup) => Slot\r\n\r\ntype SwitchRequiredParam = {tagProperty:string, types:{[tag:string]:string[]}}\r\ntype IfParam = [string, Schema, Schema, Schema?]\r\n\r\n\r\n/**\r\n * Returns true if type specification allows null.\r\n * @function\r\n * @private\r\n * @param {string|null|undefined} type a type in schema\r\n */\r\nconst nullable = (type:any):boolean => {\r\n  if (! type) return true\r\n  const lastChar = type.charAt(type.length - 1)\r\n  return type == 'null' || lastChar == '?'\r\n}\r\n\r\n/**\r\n * Builds a map from path to schema.\r\n * @function\r\n * @param {Json} schema \r\n * @returns {SchemaDb}\r\n */\r\nexport const buildDb = (schema:Schema):SchemaDb => {\r\n  const db = /** @type SchemaDb */ ({})\r\n  const inner = (schema, path) => {\r\n    db[path] = schema\r\n    switch (schema.type) {\r\n      case 'object': \r\n      case 'object?': \r\n        for (let p in schema.properties) {\r\n          inner(schema.properties[p], path + '/' + p)\r\n        }\r\n        break\r\n      case 'array': \r\n      case 'array?': \r\n        inner(schema.items, path + '/*')\r\n        break\r\n      default: \r\n        break\r\n    }\r\n  }\r\n  inner(schema, \"\")\r\n  return db\r\n}\r\n\r\n/**\r\n * Returns true if the value is in an specified type\r\n * @function\r\n * @private\r\n * @param {Json} value\r\n * @param {string} type \r\n * @returns {boolean}\r\n */\r\nconst testType = (value:Json, type:string):boolean => {\r\n  if (! type) return true\r\n  if (value === null) {\r\n    return nullable(type)\r\n  } else {\r\n    switch (type) {\r\n      case 'null': \r\n        return false\r\n      case 'number':  // FALLTHRU\r\n      case 'number?': \r\n        return typeof value == 'number'\r\n      case 'integer':  // FALLTHRU\r\n      case 'integer?': \r\n        return (typeof value == 'number' && value % 1 === 0)\r\n      case 'boolean':  // FALLTHRU\r\n      case 'boolean?': \r\n        return typeof value == 'boolean'\r\n      case 'string': \r\n        return typeof value == 'string'\r\n      case 'object':  // FALLTHRU\r\n      case 'object?': \r\n        return (typeof value == 'object' && value !== null)\r\n      case 'array':  // FALLTHRU\r\n      case 'array?': \r\n        return Array.isArray(value)\r\n      default: \r\n        throw new Error('unknown type: ' + type)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * default validation rules.\r\n * @type {Rules}\r\n */\r\nexport const defaultRules:Rules = {\r\n  type: (param, value) => {\r\n    if (typeof param != 'string') throw new Error('invalid type')\r\n    const result = testType(value, param)\r\n    if (! result) return {code:'type.'+param}\r\n    return true\r\n  }, \r\n  'enum': (param, value) => {\r\n    if (! Array.isArray(param)) throw new Error('invalid parameter')\r\n    for (let i = 0; i < param.length; i++) {\r\n      if (param[i] === value) return true\r\n    }\r\n    return {code:'rule.enum'}\r\n  }, \r\n  'const': (param, value) => {\r\n    if (param === value) return true\r\n    switch (typeOf(param)) {\r\n      case 'string': \r\n      case 'number': \r\n      case 'null': \r\n      case 'boolean': \r\n        return {code:'rule.const', hint:(param as Scalar)}\r\n      default: \r\n        return {code:'rule.const.nohint'}\r\n    }\r\n  }, \r\n  notEmpty: (_param, value) => {\r\n    if (typeOf(value) != 'string') return true\r\n    if (value !== '') return true\r\n    return {code:'rule.notEmpty'}\r\n  }, \r\n  required: (param, value) => {\r\n    if (! Array.isArray(param)) throw new Error('invalid parameter')\r\n    if (typeOf(value) != 'object') return true\r\n    for (let i = 0; i < param.length; i++) {\r\n      if (! value.hasOwnProperty(param[i] as string)) return {code:'rule.required', hint:param[i] as string}\r\n    }\r\n    return true\r\n  }, \r\n  switchRequired: (param, value, lookup) => {\r\n    if (typeOf(param) != 'object' || !('tagProperty' in (param as object))) throw new Error('invalid parameter')\r\n    if (typeOf(value) != 'object') return true\r\n    param = param as SwitchRequiredParam\r\n    const tag = lookup('0/' + param.tagProperty) as string\r\n    if (! tag) return {code:'rule.switchRequired.nohint', decription:'no tag'}\r\n    if (! param.types[tag]) return {code:'rule.switchRequired.nohint', detail:'no type'}\r\n    const required = param.types[tag]\r\n    if (! Array.isArray(required)) throw new Error('invalid parameter')\r\n    for (let i = 0; i < required.length; i++) {\r\n      if (! value.hasOwnProperty(required[i])) return {code:'rule.switchRequired', hint:required[i]}\r\n    }\r\n    return true\r\n  }, \r\n  same: (param, value, lookup) => {\r\n    if (typeof param != 'string') throw new Error('invalid parameter')\r\n    const target = lookup(param)\r\n    if (target !== value) {\r\n      switch (typeOf(target)) {\r\n        case 'string': \r\n        case 'number': \r\n        case 'null': \r\n        case 'boolean': \r\n          return {code:'rule.same', hint: target as Scalar}\r\n        default: \r\n          return {code:'rule.same.nohint'}\r\n      }\r\n    }\r\n    return true\r\n  }, \r\n  if: (param, value, lookup, rules) => {\r\n    if (typeOf(param) != 'array') throw new Error('invalid parameter')\r\n    const param1 = param as IfParam\r\n    const [target, match, then, el = {}] = param1\r\n    if (! target || ! match || ! then) throw new Error('invalid parameter')\r\n    const targetValue = lookup(target)\r\n    const targetResult = applyRules(targetValue, match, lookup, rules)\r\n    if (targetResult === true) {\r\n      return applyRules(value, then, lookup, rules)\r\n    } else {\r\n      return applyRules(value, el, lookup, rules)\r\n    }\r\n  }, \r\n  // TODO: allOf, eitherOf, not\r\n  multipleOf: (param, value) => {\r\n    if (typeof param != 'number') throw new Error('invalid parameter')\r\n    if (typeof value != 'number') return true\r\n    if (value % param === 0) return true\r\n    return {code:'rule.multipleOf', hint:param}\r\n  }, \r\n  maximum: (param, value) => {\r\n    if (typeof value != 'number') return true\r\n    if (param >= value) return true\r\n    return {code:'rule.maximum', hint:param as Scalar}\r\n  }, \r\n  exclusiveMaximum: (param, value) => {\r\n    if (typeof value != 'number') return true\r\n    if (param > value) return true\r\n    return {code:'rule.exclusiveMaximum', hint:param as Scalar}\r\n  }, \r\n  minimum: (param, value) => {\r\n    if (typeof value != 'number') return true\r\n    if (param <= value) return true\r\n    return {code:'rule.minimum', hint:param as Scalar}\r\n  }, \r\n  exclusiveMinimum: (param, value) => {\r\n    if (typeof value != 'number') return true\r\n    if (param < value) return true\r\n    return {code:'rule.exclusiveMinimum', hint:param as Scalar}\r\n  }, \r\n  maxLength: (param, value) => {\r\n    if (typeof value != 'string') return true\r\n    if (value.length <= param) return true\r\n    return {code:'rule.maxLength', hint:param as Scalar}\r\n  }, \r\n  minLength: (param, value) => {\r\n    if (typeof value != 'string') return true\r\n    if (value.length >= param) return true\r\n    return {code:'rule.minLength', hint:param as Scalar}\r\n  }, \r\n  'pattern': (param, value) => {\r\n    if (typeof param != 'string') throw new Error('invalid parameter')\r\n    if (typeof value != 'string') return true\r\n    if (new RegExp(param).test(value)) return true\r\n    return {code:'rule.pattern', hint: /** @type {string} */ (param)}\r\n  }, \r\n  maxItems: (param, value) => {\r\n    if (typeof param != 'number') throw new Error('invalid parameter')\r\n    if (! Array.isArray(value)) return true\r\n    if (value.length <= param) return true\r\n    return {code:'rule.maxItems', hint: /** @type {number} */ (param)}\r\n  }, \r\n  minItems: (param, value) => {\r\n    if (typeof param != 'number') throw new Error('invalid parameter')\r\n    if (! Array.isArray(value)) return true\r\n    if (value.length >= param) return true\r\n    return {code:'rule.minItems', hint: /** @type {number} */ (param)}\r\n  }\r\n}\r\n\r\n/**\r\n * Validates a value with a schema.\r\n * @function\r\n * @description shallow validation\r\n * @param {Rules} rules\r\n * @returns {ValidateFunc} \r\n */\r\nexport const validate = (rules:Rules):Validate => (value, slot, schema, lookup) => {\r\n  if (! isJsonValue(value)) {\r\n    if (schema && schema.type) {\r\n      const error = {code:'type.'+schema.type, detail:'given value: '+value}\r\n      return {...slot, value, invalid:true, error}\r\n    } else {\r\n      const error = {code:'value', detail:'given value: '+value}\r\n      return {...slot, value, invalid:true, error}\r\n    }\r\n  }\r\n\r\n  if (schema) {\r\n    const result = applyRules(value, schema, lookup, rules)\r\n    if (result !== true) {\r\n      return {...slot, value, invalid:true, error:result}\r\n    }\r\n  }\r\n  return {...slot, value, invalid:false, error:null}\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {Json} value \r\n * @param {Schema} schema \r\n * @param {LookupFunc} lookup \r\n * @param {Rules} rules \r\n * @returns {true|MgError}\r\n */\r\nexport const applyRules = (value:any, schema:Schema, lookup:Lookup, rules:Rules):true|MgError => {\r\n  for (let p in schema) {\r\n    const f = rules[p]\r\n    if (! f) continue\r\n    const result = f(schema[p], value, lookup, rules)\r\n    if (result !== true) return result\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * \r\n * @function\r\n * @param {string} input\r\n * @param {Slot} slot\r\n * @param {Schema} schema\r\n * @returns {Slot}\r\n */\r\nexport const coerce = (input:string, slot:Slot, schema:Schema):Slot => {\r\n  input = \"\" + input  // coerce to string\r\n  if (! schema) {\r\n    throw new Error('coerce/0: no schema')\r\n  }\r\n  if (! schema.type || typeof schema.type != 'string') {\r\n    throw new Error('coerce/1: type not specified')\r\n  }\r\n  const type = schema.type\r\n  if (['null', 'boolean', 'boolean?', 'integer', 'integer?', 'number', 'number?', 'string'].indexOf(type) == -1) {\r\n    throw new Error('coerce/2: not a coercion enabled type: ' + type)\r\n  }\r\n\r\n  switch (type) {\r\n    case 'null': \r\n      break\r\n    case 'number': \r\n    case 'number?': \r\n      const n = +input\r\n      if (\"\" + n === input) {\r\n        return {value:n, input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'integer': \r\n    case 'integer?': \r\n      const i = +input\r\n      if (\"\" + i === input && i % 1 === 0) {\r\n        return {value:i, input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'boolean': \r\n    case 'boolean?': \r\n      if (input === \"true\" || input === \"false\") {\r\n        return {value:input===\"true\", input, touched:slot.touched}\r\n      }\r\n      break\r\n    case 'string': \r\n      return {value:input, input, touched:slot.touched}\r\n  }\r\n  if (input == \"\" && nullable(type)) {\r\n    return {value:null, input, touched:slot.touched}\r\n  }\r\n  return {input, touched:slot.touched}\r\n}\r\n","// @ts-check\r\n/** @module core/errors */\r\n\r\nimport showText from 'string-template'\r\n\r\nexport type Scalar = string|number|boolean|null\r\n\r\nexport interface MgError {\r\n  code: string, \r\n  detail?: string, \r\n  hint?: Scalar, \r\n  message?: string\r\n}\r\n\r\nexport type NormalizeError = (error:MgError) => MgError\r\n\r\n/**\r\n * Returns true if a given object is an instance of MgError\r\n * @function\r\n * @param {any} x\r\n * @returns {boolean} \r\n */\r\nexport const isError = (x:any):boolean => {\r\n  return (typeof x == 'object' && x != null && 'code' in x)\r\n}\r\n\r\n /**\r\n  * Extends a MgError for viewing, and returns its extended instance.\r\n  * @function\r\n  * @param {Record<string,string>} catalog\r\n  * @returns {NormalizeErrorFunc}\r\n  */\r\nexport const normalizeError = (catalog:Record<string,string>):NormalizeError => (error) => {\r\n  const template = catalog[error.code] || catalog['detail' in error ? 'fallback' : 'fallback.nodetail']\r\n  const message = showText(template, error)\r\n  return {...error, message}\r\n}\r\n\r\n/**\r\n * @namespace\r\n */\r\nexport const defaultErrorMessages = {\r\n  /**\r\n   * @name \"fallback\"\r\n   */\r\n  'fallback': 'Error code:{code}; detail:{detail}', \r\n  /**\r\n   * @name \"fallback.nodetail\"\r\n   */\r\n  'fallback.nodetail': 'Error code:{code}', \r\n  /**\r\n   * @name \"value\"\r\n   */\r\n  'value': 'Invalid value', \r\n  /**\r\n   * @name \"type.null\"\r\n   */\r\n  'type.null': 'Please input a null value', \r\n  /**\r\n   * @name \"type.boolean\"\r\n   */\r\n  'type.boolean': 'Please input a boolean value', \r\n  /**\r\n   * @name \"type.boolean?\"\r\n   */\r\n  'type.boolean?': 'Please input a boolean value or a null', \r\n  /**\r\n   * @name \"type.integer\"\r\n   */\r\n  'type.integer': 'Please input an integer', \r\n  /**\r\n   * @name \"type.integer?\"\r\n   */\r\n  'type.integer?': 'Please input an integer or a null', \r\n  /**\r\n   * @name \"type.number\"\r\n   */\r\n  'type.number': 'Please input a number', \r\n  /**\r\n   * @name \"type.number?\"\r\n   */\r\n  'type.number?': 'Please input a number or a null', \r\n  /**\r\n   * @name \"type.string\"\r\n   */\r\n  'type.string': 'Please input a string', \r\n  /**\r\n   * @name \"type.object\"\r\n   */\r\n  'type.object': 'Please input an object value', \r\n  /**\r\n   * @name \"type.object?\"\r\n   */\r\n  'type.object?': 'Please input an object value or a null', \r\n  /**\r\n   * @name \"type.array\"\r\n   */\r\n  'type.array': 'Please input an array value', \r\n  /**\r\n   * @name \"type.array?\"\r\n   */\r\n  'type.array?': 'Please input an array value or a null', \r\n  /**\r\n   * @name \"rule.enum\"\r\n   */\r\n  'rule.enum': 'Invalid input', \r\n  /**\r\n   * @name \"rule.const\"\r\n   */\r\n  'rule.const': 'Input {hint}',  // param\r\n  /**\r\n   * @name \"rule.const.nohint\"\r\n   */\r\n  'rule.const.nohint': 'Invalid input', \r\n  /**\r\n   * @name \"rule.notEmpty\"\r\n   */\r\n  'rule.notEmpty': 'Please input', \r\n  /**\r\n   * @name \"rule.required\"\r\n   */\r\n  'rule.required': 'Missing property \"{hint}\"',  // param[i]\r\n  /**\r\n   * @name \"rule.switchRequired\"\r\n   */\r\n  'rule.switchRequired': 'Missing property \"{hint}\"',  // required[i]\r\n  /**\r\n   * @name \"rule.sqitchRequired.nohint\"\r\n   */\r\n  'rule.switchRequired.nohint': 'Properties are missing', \r\n  /**\r\n   * @name \"rule.same\"\r\n   */\r\n  'rule.same': 'Please input {hint}',  // target\r\n  /**\r\n   * @name \"rule.same.nohint\"\r\n   */\r\n  'rule.same.nohint': 'Invalid input', \r\n  /**\r\n   * @name \"rule.multipleOf\"\r\n   */\r\n  'rule.multipleOf': 'Please enter a multiple of {hint}',  // param\r\n  /**\r\n   * @name \"rule.maximum\"\r\n   */\r\n  'rule.maximum': 'Please enter {hint} or less',  // param\r\n  /**\r\n   * @name \"rule.exclusiveMaximum\"\r\n   */\r\n  'rule.exclusiveMaximum': 'Please enter less than {hint}',  // param\r\n  /**\r\n   * @name \"rule.minimum\"\r\n   */\r\n  'rule.minimum': 'Please enter {hint} or more',  // param\r\n  /**\r\n   * @name \"rule.exclusiveMinimum\"\r\n   */\r\n  'rule.exclusiveMinimum': 'Please enter more than {hint}',  // param\r\n  /**\r\n   * @name \"rule.maxLength\"\r\n   */\r\n  'rule.maxLength': 'Please enter no more than {hint} characters',  // param\r\n  /**\r\n   * @name \"rule.minLength\"\r\n   */\r\n  'rule.minLength': 'Please enter at least {hint} characters',  // param\r\n  /**\r\n   * @name \"rule.pattern\"\r\n   */\r\n  'rule.pattern': 'Invalid format',  // param\r\n  /**\r\n   * @name \"rule.maxItems\"\r\n   */\r\n  'rule.maxItems': 'Please make it {hint} or less',  // param\r\n  /**\r\n   * @name \"rule.minItems\"\r\n   */\r\n  'rule.minItems': 'Please make it {hint} or more',  // param\r\n  /**\r\n   * @name \"http.400\"\r\n   */\r\n  'http.400': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.401\"\r\n   */\r\n  'http:401': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.403\"\r\n   */\r\n  'http:403': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.404\"\r\n   */\r\n  'http.404': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.405\"\r\n   */\r\n  'http.405': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.406\"\r\n   */\r\n  'http.406': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.407\"\r\n   */\r\n  'http.407': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.408\"\r\n   */\r\n  'http.408': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.409\"\r\n   */\r\n  'http.409': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.410\"\r\n   */\r\n  'http.410': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.500\"\r\n   */\r\n  'http.500': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.501\"\r\n   */\r\n  'http.501': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.502\"\r\n   */\r\n  'http.502': 'HTTP error: {detail}', \r\n  /**\r\n   * @name \"http.503\"\r\n   */\r\n  'http.503': 'HTTP error: {detail}', \r\n\r\n}","//@ts-check\r\n\r\nimport { normalizePath } from './utils'\r\nimport * as E from './env'\r\nimport * as S from './schema'\r\nimport * as X from './errors'\r\nimport { app, h as h0, VNode, ActionType, View } from 'hyperapp'\r\nimport {MgError, NormalizeError} from './errors'\r\nimport {Json, Schema, Slot, SchemaDb, Lookup, Rules} from './schema'\r\nimport {Env} from './env'\r\n\r\nexport type Validity = {invalid:boolean, error:MgError|null}\r\n\r\ntype ThenHandler = (result:any) => any\r\ntype XThenHandler = (result:any, env:Env) => any\r\ntype Update = (...args:any[]) => Env\r\ntype DialogState = {\r\n  data: any, \r\n  fulfill: (result:any) => undefined, \r\n  reject: (result:any) => undefined\r\n}\r\ntype OnPromiseThenParam = {\r\n  result: any,\r\n  ret: (any:any) => void,\r\n  handler: XThenHandler\r\n}\r\n/*type OnUpdateByEvent<S, A> = ActionType<Event, S, A>\r\ntype OnUpdateByCall<S, A> = ActionType<{update:string, context:any[]}, S, A>\r\ntype OnUpdate<S, A> = OnUpdateByEvent<S, A>|OnUpdateByCall<S, A>*/\r\n\r\nexport interface UnmagicalState {\r\n  baseEnv: Env, \r\n  env: Env, \r\n  normalizeError: NormalizeError\r\n}\r\n\r\nexport interface UnmagicalActions {\r\n  onTextboxInput: UnmagicalAction<Event>, \r\n  onTextboxBlur: UnmagicalAction<Event>, \r\n  onSliderInput: UnmagicalAction<Event>, \r\n  onSliderChange: UnmagicalAction<Event>, \r\n  onListboxChange: UnmagicalAction<Event>, \r\n  onRadioChange: UnmagicalAction<Event>, \r\n  onCheckboxChange: UnmagicalAction<Event>, \r\n  onSmartControlChange: UnmagicalAction<{path:string,input:string}|[{path:string,input:string}]>, \r\n  onUpdate: UnmagicalAction<Event|{update:string,context:any[]}>, \r\n  onPromiseSettle: UnmagicalAction<Event|{name:string,result:any}>, \r\n  onPromiseThen: UnmagicalAction<OnPromiseThenParam>\r\n}\r\n\r\nexport type UnmagicalAction<T> = ActionType<T, UnmagicalState, UnmagicalActions>\r\n\r\nexport interface StartParameter {\r\n  data: Json, \r\n  schema: Schema, \r\n  view: (env:Env) => VNode, \r\n  containerEl: Element, \r\n  evolve?: (env:Env, updatePointer:string|null, prevEnv:Env|null) => Env, \r\n  updates?: Record<string,Update>\r\n  rules?: Rules, \r\n  catalog?: Record<string,string>\r\n}\r\n\r\nexport interface StartValue {\r\n  onUpdate: UnmagicalAction<Event|{update:string,context:any[]}>\r\n}\r\n\r\nexport interface OnceParameter {\r\n  data: Json, \r\n  schema: Schema, \r\n  evolve?: (env:Env, updatePointer:string|null, prevEnv:Env|null) => Env, \r\n  rules?: Rules\r\n}\r\n\r\n/**\r\n * @namespace\r\n */\r\nexport namespace API {\r\n  // re-export from env\r\n  export const test = E.test\r\n  export const extract = E.extract\r\n  export const getSlot = E.getSlot\r\n  export const add = E.add\r\n  export const remove = E.remove\r\n  export const replace = E.replace\r\n  export const move = E.move\r\n  export const copy = E.copy\r\n  export const duplicate = E.duplicate\r\n  export const validate = E.validate\r\n  export const mapDeep = E.mapDeep\r\n  export const reduceDeep = E.reduceDeep\r\n  export const getExtra = E.getExtra\r\n\r\n  /**\r\n   * \r\n   * @param {string} path \r\n   * @param {Env} env\r\n   * @returns {Env} \r\n   */\r\n  export const touchAll = (path:string, env:Env):Env => {\r\n    return E.mapDeep((slot, _path) => ({...slot, touched:true}), path, env)\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {string} path \r\n   * @param {Env} env\r\n   * @returns {number} \r\n   */\r\n  export const countValidationErrors = (path:string, env:Env):number => {\r\n    return E.reduceDeep((cur, slot, _path) => {\r\n      const d = slot.touched && slot.invalid ? 1 : 0\r\n      return cur + d\r\n    }, 0, path, env)\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {string} path \r\n   * @param {Env} env\r\n   * @returns {string[]} \r\n   */\r\n  export const validationErrors = (path:string, env:Env):string[] => {\r\n    const errors:string[] = []\r\n    E.reduceDeep((_cur, slot, path) => {\r\n      if (slot.touched && slot.invalid) {\r\n        errors.push(path)\r\n      }\r\n      return null\r\n    }, null, path, env)\r\n    return errors\r\n  }\r\n\r\n  /**\r\n   * @param {string} path\r\n   * @param {Env} env\r\n   * @returns {{invalid:boolean, error:MgError|null}}\r\n   */\r\n  export const foldValidity = (path:string, env:Env):Validity => {\r\n    return API.reduceDeep<Validity>((cur, slot, _path) => {\r\n      if (cur.invalid) return cur\r\n      if (slot.touched && slot.invalid) return {invalid:true, error:slot.error}\r\n      return cur\r\n    }, {invalid:false, error:null}, path, env)\r\n  }\r\n\r\n  /**\r\n   * @param {number} ms\r\n   * @param {Env} env\r\n   * @returns {[Promise, Env]}\r\n   */\r\n  export const sleep = (ms:number, env:Env):[Promise<null>, Env] => {\r\n    const p = new Promise<null>((fulfill, reject) => {\r\n      setTimeout(() => {\r\n        fulfill(null)\r\n      }, ms)\r\n    })\r\n    return [p, env]\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {string} itemPath\r\n   * @param {string} group\r\n   * @param {Env} env\r\n   * @returns {[Promise, Env]}\r\n   */\r\n  export const startReordering = <T>(name:string, itemPath:string, group:string, env:Env):[Promise<T>, Env] => {\r\n    const p = new Promise<T>((fulfill, reject) => {\r\n      env = E.setExtra(name, {itemPath, group, fulfill, reject}, env)\r\n    })\r\n    return [p, env]\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const endReordering = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env)\r\n    if (! extra) return env\r\n    return E.setExtra(name, null, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {string|null}\r\n   */\r\n  export const getReordering = (name:string, env:Env):string|null => {\r\n    const extra = E.getExtra(name, env) as {itemPath:string}|null\r\n    if (! extra) return null\r\n    return extra.itemPath\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {any} data\r\n   * @param {Env} env\r\n   * @returns {[Promise, Env]}\r\n   */\r\n  export const openDialog = (name:string, data:any, env:Env):[Promise<boolean>,Env] => {\r\n    const p = new Promise<boolean>((fulfill, reject) => {\r\n      env = E.setExtra(name, {data, fulfill, reject}, env)\r\n    })\r\n    return [p, env]\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const closeDialog = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env)\r\n    if (! extra) return env\r\n    return E.setExtra(name, null, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {any|null}\r\n   */\r\n  export const getDialog = (name:string, env:Env):any|null => {\r\n    const extra = E.getExtra(name, env) as DialogState|null\r\n    if (! extra) return null\r\n    return extra.data\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {any} data\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const openFeedback = (name:string, data:any, env:Env):Env => {\r\n    return E.setExtra(name, data, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const closeFeedback = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env)\r\n    if (! extra) return env\r\n    return E.setExtra(name, null, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {any|null}\r\n   */\r\n  export const getFeedback = (name:string, env:Env):any|null => {\r\n    return E.getExtra(name, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {number} current\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const setPage = (name:string, current:number, env:Env):Env => {\r\n    return E.setExtra(name, current, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {number}\r\n   */\r\n  export const getPage = (name:string, env:Env):number => {\r\n    const extra = E.getExtra(name, env) as number|null\r\n    return (extra !== null) ? extra : 0\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const nextPage = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env) as number|null\r\n    const current = (extra !== null) ? extra : 0\r\n    return E.setExtra(name, current + 1, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const prevPage = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env) as number|null\r\n    const current = (extra !== null) ? extra : 0\r\n    return E.setExtra(name, current - 1, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {boolean} shown\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const setSwitch = (name:string, shown:boolean, env:Env):Env => {\r\n    return E.setExtra(name, shown, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {boolean}\r\n   */\r\n  export const getSwitch = (name:string, env:Env):boolean => {\r\n    const extra = E.getExtra(name, env) as boolean|null\r\n    return (extra !== null) ? extra : false\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const toggleSwitch = (name:string, env:Env):Env => {\r\n    const extra = E.getExtra(name, env) as boolean|null\r\n    const current = (extra !== null) ? extra : false\r\n    return E.setExtra(name, !current, env)\r\n  }\r\n\r\n  /*\r\n   * TODO: progress bar, ReadStream, ...\r\n   */\r\n  /**\r\n   * @param {string} name\r\n   * @param {any} unknown\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const openProgress = (name:string, unknown:any, env:Env):Env => {\r\n    return E.setExtra(name, {current:-1}, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {Env}\r\n   */\r\n  export const closeProgress = (name:string, env:Env):Env => {\r\n    return E.setExtra(name, null, env)\r\n  }\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @param {Env} env\r\n   * @returns {number|null}\r\n   */\r\n  export const getProgress = (name:string, env:Env):number|null => {\r\n    const extra = E.getExtra(name, env) as {current:number}|null\r\n    if (! extra) return null\r\n    return extra.current\r\n  }\r\n  \r\n  /**\r\n   * @param {string} name \r\n   * @param {string} fromPath \r\n   * @param {string} group\r\n   * @param {Env} env\r\n   * @returns {Env|Promise}\r\n   */\r\n  export const reorder = (name:string, fromPath:string, group:string, env:Env):Env|Promise<{path:string}> => {\r\n    const {enter, leave} = API.makePortal(env)\r\n    return leave(API.startReordering<{path:string}>(name, fromPath, group, env))\r\n    .then(enter(({path}, env) => {\r\n      env = API.endReordering(name, env)\r\n      return API.move(fromPath, path, env)\r\n    }))\r\n  }\r\n\r\n  /**\r\n   * @param {Env} env\r\n   */\r\n  export const makePortal = (env:Env) => {\r\n    return {\r\n      /**\r\n       * @param {(result:any, env:Env) => any} handler\r\n       * @returns {(result:any) => any}\r\n       */\r\n      enter: (handler:XThenHandler):ThenHandler => {  // Our customized handler :: [result, env] => ...\r\n        return (result) => {  // This is the actual, standard promise handler\r\n          let result1 = null  // We will get the result in this variable.\r\n          const ret = (res1) => {result1 = res1}\r\n          (env.onPromiseThen as UnmagicalAction<OnPromiseThenParam>)({result, handler, ret})  // enter into hyperapp. Its result is undefined.\r\n          return result1\r\n        }\r\n      }, \r\n      /**\r\n       * @param {[(Promise|Error), Env] | (Promise|Error)} x\r\n       * @param {Env} [y]\r\n       * @returns {Promise|Error}\r\n       */\r\n      leave: <T>(x:[T, Env]|T, y?:Env):T => {\r\n        const p = Array.isArray(x) ? x[0] : x\r\n        const env = Array.isArray(x) ? x[1] : y\r\n        if (! E.isEnv(env)) throw new Error('exit/1: env required')\r\n        E.doReturn(env)\r\n        return p\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst updateEnabledApis = {\r\n  openDialog: API.openDialog, \r\n  closeDialog: API.closeDialog, \r\n  openFeedback: API.openFeedback, \r\n  closeFeedback: API.closeFeedback, \r\n  openProgress: API.openProgress, \r\n  closeProgress: API.closeProgress, \r\n  setPage: API.setPage, \r\n  nextPage: API.nextPage, \r\n  prevPage: API.prevPage, \r\n  setSwitch: API.setSwitch, \r\n  toggleSwitch: API.toggleSwitch, \r\n  reorder: API.reorder\r\n}\r\n\r\n/**\r\n * @param {Object} params\r\n * @param {Json} params.data\r\n * @param {Schema} params.schema\r\n * @param {(env:Env) => import('hyperapp').VNode} params.view\r\n * @param {Element} params.containerEl\r\n * @param {((env:Env, updatePointer:string, prevEnv:Env|null) => Env) | null} params.evolve\r\n * @param {{[name:string]:(any)}} params.updates\r\n * @param {Rules} params.rules\r\n * @param {Record<string,string>} params.catalog\r\n */\r\nexport const start = (\r\n    {\r\n      data, \r\n      schema, \r\n      view, \r\n      containerEl, \r\n      evolve = null, \r\n      updates = {}, \r\n      rules = null, \r\n      catalog = null\r\n    }:StartParameter):StartValue => {\r\n  // complements reasonable defaults\r\n  if (! evolve) evolve = (env, _pointer, _prevEnv) => env\r\n  const validate = S.validate(rules || S.defaultRules)\r\n  const coerce = S.coerce\r\n  const normalizeError = X.normalizeError(catalog || X.defaultErrorMessages)\r\n\r\n  const schemaDb = S.buildDb(schema)\r\n\r\n  const actions0 = {\r\n    onTextboxInput: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const slot0 = E.getSlot(path, state.baseEnv)\r\n      const slot = {...slot0, input:value}\r\n      const baseEnv = E.setSlot(path, slot, state.baseEnv)\r\n      // We don't call evolve() here, because oninput is not a check point of evolve().\r\n      // Thus we update not only baseEnv but also env.\r\n      const slotb0 = E.getSlot(path, state.env)\r\n      const slotb = {...slotb0, input:value}\r\n      const env = E.setSlot(path, slotb, state.env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onTextboxBlur: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const npath = normalizePath(path)\r\n      const slot0 = {...E.getSlot(path, state.baseEnv), touched:true}\r\n      const slot = coerce(value, slot0, schemaDb[npath])\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setSlot(path, slot, baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, baseEnv)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onSliderInput: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const slot0 = E.getSlot(path, state.baseEnv)\r\n      const slot = {...slot0, input:value}\r\n      const baseEnv = E.setSlot(path, slot, state.baseEnv)\r\n      // We don't call evolve() here, because oninput is not a check point of evolve().\r\n      // Thus we update not only baseEnv but also env.\r\n      const slotb0 = E.getSlot(path, state.env)\r\n      const slotb = {...slotb0, input:value}\r\n      const env = E.setSlot(path, slotb, state.env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onSliderChange: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const npath = normalizePath(path)\r\n      const slot0 = {...E.getSlot(path, state.baseEnv), touched:true}\r\n      const slot = coerce(value, slot0, schemaDb[npath])\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setSlot(path, slot, baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, state.env)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onListboxChange: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const npath = normalizePath(path)\r\n      const slot0 = {...E.getSlot(path, state.baseEnv), touched:true}\r\n      const slot = coerce(value, slot0, schemaDb[npath])\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setSlot(path, slot, baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, state.env)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onRadioChange: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const value = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgValueAttribute]\r\n      const npath = normalizePath(path)\r\n      const slot0 = {...E.getSlot(path, state.baseEnv), touched:true}\r\n      const slot = coerce(value, slot0, schemaDb[npath])\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setSlot(path, slot, baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, state.env)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onCheckboxChange: (ev:Event) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const path = (ev.currentTarget as HTMLElement).dataset.mgPath\r\n      const checked = ev.currentTarget[(ev.currentTarget as HTMLElement).dataset.mgCheckedAttribute]\r\n      const value = checked ? \"true\" : \"false\"\r\n      const npath = normalizePath(path)\r\n      const slot0 = {...E.getSlot(path, state.baseEnv), touched:true}\r\n      const slot = coerce(value, slot0, schemaDb[npath])\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setSlot(path, slot, baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, state.env)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onSmartControlChange: (pair:{path:string,input:string}|[{path:string,input:string}]) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const pairs = Array.isArray(pair) ? pair : [pair]\r\n      let updatePointer\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      for (let i = 0; i < pairs.length; i++) {\r\n        const {path, input} = pairs[i]\r\n        const slot0 = {...E.getSlot(path, baseEnv), touched:true}\r\n        const slot = coerce(input, slot0, schemaDb[normalizePath(path)])\r\n        baseEnv = E.setSlot(path, slot, baseEnv)\r\n      }\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = evolve(baseEnv, updatePointer, state.env)\r\n      env = E.validate(\"\", env)\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onUpdate: (ev:Event|{update:string,context:any[]}) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const update = ('currentTarget' in ev) ? (ev.currentTarget as HTMLElement).dataset.mgUpdate : ev.update\r\n      const context = ('currentTarget' in ev) ? JSON.parse((ev.currentTarget as HTMLElement).dataset.mgContext || \"null\") : ev.context\r\n      let updatePointer:string\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setPortal((env0) => {baseEnv = env0}, actions.onPromiseThen, baseEnv)\r\n      const func = updates[update] || updateEnabledApis[update]\r\n      if (! func) throw new Error('onUpdate/0: no update or unknown update')\r\n      if (! Array.isArray(context)) throw new Error('onUpdate/1: parameter must be an array')\r\n      if (context.length + 1 != func.length) throw new Error('onUpdate/2: bad number of parameters')\r\n      const res = func.apply(null, [...context, baseEnv])\r\n      baseEnv = E.setPortal(null, null, E.isEnv(res) ? res : baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = state.env\r\n      if (! E.isSame(state.baseEnv, baseEnv)) {\r\n        env = evolve(baseEnv, updatePointer, env)\r\n        env = E.validate(\"\", env)\r\n      }\r\n      return {...state, baseEnv, env}\r\n    }, \r\n    onPromiseSettle: (ev:Event|{name:string,result:any}) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      const name = ('currentTarget' in ev) ? (ev.currentTarget as HTMLElement).dataset.mgName : ev.name\r\n      const result = ('currentTarget' in ev) ? JSON.parse((ev.currentTarget as HTMLElement).dataset.mgResult || \"null\") : ev.result\r\n      const extra = E.getExtra(name, state.baseEnv) as DialogState\r\n      if (! extra || ! extra.fulfill) throw new Error('onPromiseSettle/0: no callback or unknown callback')\r\n      // Calling fulfill() will cause the process to re-enter the hyperapp, \r\n      // so we call fulfill() not now but in a different opportunity.\r\n      setTimeout(() => {\r\n        extra.fulfill(result)\r\n      }, 0)\r\n      return null  // indicating no update.\r\n    }, \r\n    onPromiseThen: (context:OnPromiseThenParam) => (state:UnmagicalState, actions:UnmagicalActions) => {\r\n      let updatePointer:string\r\n      let baseEnv = E.beginUpdateTracking(state.baseEnv)\r\n      baseEnv = E.setPortal((env0) => {baseEnv = env0}, actions.onPromiseThen, baseEnv)\r\n      const res = context.handler(context.result, baseEnv)\r\n      baseEnv = E.setPortal(null, null, E.isEnv(res) ? res : baseEnv)\r\n      baseEnv = E.validate(\"\", baseEnv);\r\n      [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n      let env = state.env\r\n      if (! E.isSame(state.baseEnv, baseEnv)) {\r\n        env = evolve(baseEnv, updatePointer, env)\r\n        env = E.validate(\"\", env)\r\n      }\r\n      if (! E.isEnv(res)) {\r\n        context.ret(res)\r\n      }\r\n      return {...state, baseEnv, env}\r\n    }\r\n  }\r\n\r\n  let updatePointer:string\r\n  let baseEnv = E.makeEnv(data, schemaDb, validate, true)\r\n  baseEnv = E.validate(\"\", baseEnv);\r\n  [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n  let env = evolve(baseEnv, updatePointer, null)\r\n  env = E.validate(\"\", env)\r\n  const state:UnmagicalState = {\r\n    baseEnv, \r\n    env, \r\n    normalizeError\r\n  }\r\n  const view1:View<UnmagicalState, UnmagicalActions> = (state, actions) => view(state.env)\r\n  const actions = app(state, actions0, view1, containerEl)\r\n  return {\r\n    onUpdate: actions.onUpdate, \r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} params\r\n * @param {Json} params.data\r\n * @param {Schema} params.schema\r\n * @param {((env:Env, updatePointer:string, prevEnv:Env|null) => Env) | null} params.evolve\r\n * @param {Rules} params.rules\r\n */\r\nexport const once = (\r\n    {\r\n      data, \r\n      schema, \r\n      evolve = null, \r\n      rules = null\r\n    }:OnceParameter):Env => {\r\n  // complements reasonable defaults\r\n  if (! evolve) evolve = (env, _pointer, _prevEnv) => env\r\n  const validate = S.validate(rules || S.defaultRules)\r\n\r\n  const schemaDb = S.buildDb(schema)\r\n  \r\n  let updatePointer\r\n  let baseEnv = E.makeEnv(data, schemaDb, validate, true)\r\n  baseEnv = E.validate(\"\", baseEnv);\r\n  [updatePointer, baseEnv] = E.endUpdateTracking(baseEnv)\r\n  let env = evolve(baseEnv, updatePointer, null)\r\n  env = E.validate(\"\", env)\r\n  return env\r\n}\r\n\r\nexport const h = h0","import {once, API} from '../../src/core/framework'\r\n\r\nconst master = {\r\n  frame: [\r\n    {name:'SC130-T', price:32000}\r\n  ], \r\n  os: [\r\n    {name:'Home', price:8000}, \r\n    {name:'Pro', price:13000}\r\n  ], \r\n  cpu: [\r\n    {name:'i7', price:24000}, \r\n    {name:'i5', price:16000}, \r\n    {name:'i3', price:10000}\r\n  ], \r\n  memory: [\r\n    {name:'4G', price:10000}, \r\n    {name:'8G', price:20000}, \r\n    {name:'16G', price:40000}, \r\n    {name:'32G', price:80000}\r\n  ], \r\n  accessory: [\r\n    {name:'Keyboard', price:2000}, \r\n    {name:'Mouse', price:2000}, \r\n    {name:'Touch Pad', price:2000}, \r\n    {name:'Monitor', price:20000}\r\n  ], \r\n  bonus: [\r\n    {name:'Mobile Wi-Fi Adaptor', price:0}, \r\n    {name:'Touchauth Component', price:0}\r\n  ]\r\n}\r\n\r\nconst schema = {\r\n  type: 'object', \r\n  properties: {\r\n    detail: {\r\n      type: 'object', \r\n      properties: {\r\n        frame: {type:'string', notEmpty:true}, \r\n        os: {type:'string', notEmpty:true}, \r\n        cpu: {type:'string', notEmpty:true}, \r\n        memory: {type:'string', notEmpty:true}, \r\n        accessories: {\r\n          type: 'object', \r\n          properties: master.accessory.reduce((cur, a, i) => {\r\n            return {...cur, [`a${i}`]:{type:'boolean'}}\r\n          }, {})\r\n        }, \r\n        bonus: {type:'string', notEmpty:true}\r\n      }\r\n    }, \r\n    flags: {\r\n      type: 'object', \r\n      properties: {\r\n        isPro: {type:'boolean'}, \r\n        bigDeal: {type:'boolean'}\r\n      }\r\n    }, \r\n    quotation: {\r\n      type: 'object', \r\n      properties: {\r\n        lines: {\r\n          type: 'array', \r\n          items: {\r\n            type: 'object', \r\n            properties: {\r\n              category: {type:'string'}, \r\n              description: {type:'string'}, \r\n              unitPrice: {type:'integer'}, \r\n              quantity: {type:'integer'}, \r\n              amount: {type:'integer'}\r\n            }\r\n          }\r\n        }, \r\n        subtotal: {type:'integer'}, \r\n        tax: {type:'integer'}, \r\n        total: {type:'integer'}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst data = {\r\n  detail: {\r\n    \"frame\": \"SC130-T\",\r\n    \"os\": \"Pro\",\r\n    \"cpu\": \"i5\",\r\n    \"memory\": \"16G\",\r\n    \"accessories\": {\r\n      \"a0\": false,\r\n      \"a1\": false,\r\n      \"a2\": true,\r\n      \"a3\": false\r\n    },\r\n    \"bonus\": \"Touchauth Component\"\r\n  }, \r\n  flags: {\r\n    isPro: false, \r\n    bigDeal: false\r\n  }, \r\n  quotation: {\r\n    lines: [], \r\n    subtotal: 0, \r\n    tax: 0, \r\n    total: 0\r\n  }\r\n}\r\n\r\nconst findByProp = (name, value, lis) => {\r\n  for (let i = 0; i < lis.length; i++) {\r\n    if (lis[i][name] == value) return lis[i]\r\n  }\r\n  return undefined\r\n}\r\nconst evolve = (env, path, prevEnv) => {\r\n  const addLine = (category, x, env) => {\r\n    const line = {category, description:x.name, unitPrice:x.price, quantity:1, amount:x.price}\r\n    return API.add('/quotation/lines/-', line, env)\r\n  }\r\n  let subtotal = 0\r\n  let isPro = false\r\n  let detail = API.extract('/detail', env)\r\n  if (detail.frame) {\r\n    const frame = findByProp('name', detail.frame, master.frame)\r\n    env = addLine('', frame, env)\r\n    subtotal += frame.price\r\n  }\r\n  if (detail.os) {\r\n    const os = findByProp('name', detail.os, master.os)\r\n    env = addLine('OS', os, env)\r\n    subtotal += os.price\r\n    if (os.name == 'Pro') isPro = true\r\n  }\r\n  if (detail.cpu) {\r\n    const cpu = findByProp('name', detail.cpu, master.cpu)\r\n    env = addLine('CPU', cpu, env)\r\n    subtotal += cpu.price\r\n  }\r\n  env = API.add('/flags/isPro', isPro, env)\r\n  if (! isPro && detail.memory && detail.memory == '32G') {\r\n    env = API.add('/detail/memory', '', env)\r\n    detail = API.extract('/detail', env)  // we modified `/detail' so load again.\r\n  }\r\n  if (detail.memory) {\r\n    const memory = findByProp('name', detail.memory, master.memory)\r\n    env = addLine('', memory, env)\r\n    subtotal += memory.price\r\n  }\r\n  master.accessory.forEach((a, i) => {\r\n    if (detail.accessories[`a${i}`]) {\r\n      env = addLine('', a, env)\r\n      subtotal += a.price\r\n    }\r\n  })\r\n  const bigDeal = subtotal >= 70000\r\n  env = API.add('/flags/bigDeal', bigDeal, env)\r\n  if (! bigDeal) {\r\n    env = API.remove('/detail/bonus', env)\r\n    detail = API.extract('/detail', env)  // we modified `/detail' so load again.\r\n  }\r\n  if (detail.bonus) {\r\n    const bonus = findByProp('name', detail.bonus, master.bonus)\r\n    env = addLine('', bonus, env)\r\n    subtotal += bonus.price\r\n  }\r\n  env = API.add('/quotation/subtotal', subtotal, env)\r\n  env = API.add('/quotation/tax', subtotal / 10, env)\r\n  env = API.add('/quotation/total', subtotal + subtotal / 10, env)\r\n  return env\r\n}\r\n\r\nlet env = once({schema, data, evolve})\r\nenv = API.touchAll(\"\", env)\r\nenv = API.validate(\"\", env)\r\nconst numErrors = API.countValidationErrors(\"\", env)\r\nif (numErrors) {\r\n  console.error('ERROR: some validation errors occurred', env.tree)\r\n} else {\r\n  const result = API.extract(\"\", env)\r\n  console.log(\"SUCCESS\", result)\r\n}"]}